<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DCF Hungary</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><circle cx='50' cy='50' r='40' fill='%23dc3545'/></svg>">
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="../js/dcf-unified-auth.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            background: #f8f9fa;
        }

        .header {
            background: white;
            border-bottom: 1px solid #e5e5e5;
            padding: 1rem 0;
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .nav-container {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 2rem;
        }

        .logo {
            display: flex;
            align-items: center;
            font-weight: 600;
            color: #333;
            text-decoration: none;
        }

        .logo-icon {
            width: 24px;
            height: 24px;
            background: #333;
            border-radius: 50%;
            margin-right: 8px;
        }

        .nav-menu {
            display: flex;
            list-style: none;
            gap: 2rem;
        }

        .nav-menu a {
            text-decoration: none;
            color: #666;
            font-size: 0.9rem;
            position: relative;
        }

        .nav-menu a.active {
            color: #333;
            font-weight: 600;
        }

        .nav-menu a:hover {
            color: #333;
        }

        .user-menu {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .user-menu {
            position: relative;
        }

        .user-dropdown {
            position: relative;
        }

        .dropdown-menu {
            position: absolute;
            top: calc(100% + 8px);
            right: 0;
            background: white;
            border-radius: 12px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);
            border: 1px solid #e5e5e5;
            min-width: 280px;
            opacity: 0;
            visibility: hidden;
            transform: translateY(-10px);
            transition: all 0.3s ease;
            z-index: 1000;
        }

        .dropdown-menu.active {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }

        .dropdown-header {
            display: flex;
            align-items: center;
            gap: 1rem;
            padding: 1.5rem;
            border-bottom: 1px solid #f0f0f0;
        }

        .user-avatar {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #f0f0f0;
            color: #666;
            font-weight: 600;
            font-size: 0.75rem;
            transition: all 0.2s ease;
            box-sizing: border-box;
            overflow: hidden;
        }

        .user-avatar:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .dropdown-avatar {
            width: 48px;
            height: 48px;
            min-width: 48px;
            min-height: 48px;
            border-radius: 50%;
            background: linear-gradient(135deg, #000, #333);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
            font-size: 1rem;
            flex-shrink: 0;
            box-sizing: border-box;
            overflow: hidden;
        }

        .dropdown-info {
            flex: 1;
            min-width: 0;
        }

        .dropdown-name {
            font-weight: 600;
            color: #333;
            font-size: 1rem;
            margin-bottom: 0.25rem;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .dropdown-email {
            color: #666;
            font-size: 0.85rem;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .dropdown-divider {
            height: 1px;
            background: #f0f0f0;
            margin: 0.5rem 0;
        }

        .dropdown-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.75rem 1.5rem;
            color: #333;
            text-decoration: none;
            transition: all 0.2s ease;
            border: none;
            background: none;
            width: 100%;
            text-align: left;
            cursor: pointer;
            font-size: 0.9rem;
        }

        .dropdown-item:hover {
            background: #f8f9fa;
            color: #000;
        }

        .logout-btn {
            color: #dc3545 !important;
            font-weight: 500;
        }

        .logout-btn:hover {
            background: #fee !important;
            color: #c82333 !important;
        }

        .dropdown-icon {
            font-size: 1rem;
            width: 20px;
            text-align: center;
            flex-shrink: 0;
        }

        .dropdown-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 999;
            display: none;
        }

        .dropdown-overlay.active {
            display: block;
        }

        /* Event Cover Photo */
        .event-hero {
            position: relative;
            height: 350px;
            margin-bottom: 2rem;
            border-radius: 16px;
            overflow: hidden;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        
        /* Edit Cover Button */
        .edit-cover-btn {
            position: absolute;
            top: 1rem;
            right: 1rem;
            z-index: 10; /* Increased z-index */
            padding: 0.75rem 1.25rem;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 8px;
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            gap: 0.5rem;
            pointer-events: auto; /* Ensure pointer events work */
        }
        
        .edit-cover-btn:hover {
            background: rgba(0, 0, 0, 0.95);
            border-color: white;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        
        /* Owner Controls */
        .owner-controls {
            margin-top: 1.5rem;
            display: flex;
            gap: 1rem;
        }
        
        .manage-event-btn {
            padding: 0.75rem 1.5rem;
            background: white;
            color: #333;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .manage-event-btn:hover {
            background: #f8f9fa;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        
        /* Cover Edit Modal */
        .cover-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }
        
        .cover-modal.active {
            display: flex;
        }
        
        .cover-modal-content {
            background: white;
            border-radius: 12px;
            width: 90%;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
        }
        
        .cover-modal-header {
            padding: 1.5rem;
            border-bottom: 1px solid #e5e5e5;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .cover-modal-header h3 {
            margin: 0;
            font-size: 1.25rem;
            font-weight: 600;
        }
        
        .close-modal {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: #666;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .close-modal:hover {
            color: #333;
        }
        
        .cover-modal-body {
            padding: 2rem;
        }
        
        .upload-area {
            border: 2px dashed #e5e5e5;
            border-radius: 8px;
            padding: 2rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            min-height: 200px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .upload-area:hover {
            border-color: #333;
            background: #f8f9fa;
        }
        
        .upload-placeholder {
            width: 100%;
        }
        
        .image-preview {
            width: 100%;
            height: auto;
            border-radius: 8px;
            display: none;
        }
        
        .cover-modal-footer {
            padding: 1.5rem;
            border-top: 1px solid #e5e5e5;
            display: flex;
            justify-content: flex-end;
            gap: 1rem;
        }
        
        .btn-cancel {
            padding: 0.75rem 1.5rem;
            background: #f8f9fa;
            border: 1px solid #e5e5e5;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
        }
        
        .btn-save {
            padding: 0.75rem 1.5rem;
            background: #333;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
        }
        
        .btn-save:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        
        .btn-save:not(:disabled):hover {
            background: #000;
        }

        .hero-background {
            position: absolute;
            inset: 0;
            background-size: cover;
            background-position: center;
            z-index: 1;
        }

        .hero-overlay {
            position: absolute;
            inset: 0;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.4), rgba(0, 0, 0, 0.2));
            z-index: 2;
        }

        .hero-content {
            position: relative;
            z-index: 3;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 3rem;
            color: white;
            text-align: center;
        }

        .hero-title {
            font-size: 3rem;
            font-weight: 800;
            text-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
            margin: 0 0 1rem 0;
        }

        .hero-subtitle {
            font-size: 1.3rem;
            font-weight: 500;
            text-shadow: 0 2px 6px rgba(0, 0, 0, 0.4);
            opacity: 0.9;
            max-width: 600px;
            margin: 0;
            line-height: 1.4;
        }

        /* About Section Styling */
        .about-section {
            background: white;
            border-radius: 12px;
            padding: 2rem;
            margin-bottom: 2rem;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }

        .about-title {
            font-size: 2rem;
            font-weight: 700;
            color: #333;
            margin-bottom: 0.5rem;
            margin-top: 0;
        }
        
        .event-url-link {
            display: inline-block;
            font-size: 1rem;
            color: #0066cc;
            text-decoration: none;
            margin-bottom: 1.5rem;
            transition: color 0.3s ease;
        }
        
        .event-url-link:hover {
            color: #0052a3;
            text-decoration: underline;
        }

        .event-website-link {
            display: inline-block;
            margin: 1rem 0 1.5rem 0;
            color: #007bff;
            text-decoration: none;
            font-size: 1.35rem;
            font-weight: 500;
        }

        .event-website-link:hover {
            color: #0056b3;
            text-decoration: underline;
        }
        
        /* Like/Share Button Styles */
        .interaction-btn {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.75rem 1.5rem;
            background: white;
            border: 2px solid #e5e5e5;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
            color: #666;
        }

        .interaction-btn:hover {
            border-color: #333;
            color: #333;
        }

        .interaction-btn.active {
            background: #ff4757;
            color: white;
            border-color: #ff4757;
        }
        
        .interaction-btn span:first-child {
            transition: transform 0.3s ease;
        }
        
        .interaction-btn:disabled {
            cursor: not-allowed;
        }

        .share-dropdown {
            position: relative;
        }

        .share-menu {
            position: absolute;
            top: 100%;
            right: 0;
            background: white;
            border: 1px solid #e5e5e5;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            padding: 0.5rem;
            min-width: 200px;
            z-index: 10;
            display: none;
        }

        .share-menu.active {
            display: block;
        }

        .share-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.75rem;
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.2s ease;
        }

        .share-item:hover {
            background: #f8f9fa;
        }
        
        /* Related Events Card */
        .related-events-card {
            background: white;
            border-radius: 12px;
            padding: 1.5rem;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }
        
        .related-event-item {
            padding: 1rem;
            border: 1px solid #e5e5e5;
            border-radius: 8px;
            margin-bottom: 0.75rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .related-event-item:hover {
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            border-color: #333;
        }
        
        .related-event-title {
            font-weight: 600;
            color: #333;
            margin-bottom: 0.5rem;
        }
        
        .related-event-desc {
            font-size: 0.85rem;
            color: #666;
            line-height: 1.4;
        }
        
        .related-events-more-btn {
            width: 100%;
            padding: 0.75rem 1.5rem;
            margin-top: 1rem;
            background: #333;
            border: none;
            border-radius: 8px;
            color: white;
            font-weight: 600;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .related-events-more-btn:hover {
            background: #000;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        
        /* Cover Position Controls */
        .cover-position-controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            border-radius: 12px;
            padding: 20px;
            color: white;
            z-index: 1000;
            min-width: 400px;
        }
        
        .position-info {
            text-align: center;
            margin-bottom: 15px;
            font-size: 14px;
            opacity: 0.9;
        }
        
        .position-slider-container {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .position-btn {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            width: 40px;
            height: 40px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }
        
        .position-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.1);
        }
        
        #positionSlider {
            flex: 1;
            height: 6px;
            -webkit-appearance: none;
            appearance: none;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
            outline: none;
        }
        
        #positionSlider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: white;
            border-radius: 50%;
            cursor: pointer;
        }
        
        #positionSlider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: white;
            border-radius: 50%;
            cursor: pointer;
        }
        
        .position-actions {
            display: flex;
            gap: 10px;
            justify-content: center;
        }
        
        .position-save-btn, .position-cancel-btn {
            padding: 10px 25px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            font-size: 14px;
            transition: all 0.3s ease;
        }
        
        .position-save-btn {
            background: #4CAF50;
            color: white;
        }
        
        .position-save-btn:hover {
            background: #45a049;
            transform: translateY(-2px);
        }
        
        .position-cancel-btn {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }
        
        .position-cancel-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }
        
        .cover-photo.repositioning {
            cursor: ns-resize;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }
        
        .cover-photo.repositioning * {
            pointer-events: none;
        }

        .about-content {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 2rem;
            align-items: start;
        }
        
        .right-column {
            position: sticky;
            top: 1rem;
            max-height: 90vh;
            overflow-y: auto;
        }

        .about-description {
            color: #666;
            line-height: 1.7;
            font-size: 1.1rem;
        }

        .description-more {
            color: #007bff;
            font-style: italic;
            cursor: pointer;
            text-decoration: underline;
        }

        .description-more:hover {
            color: #0056b3;
        }

        .author-card {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 1.5rem;
            border: 1px solid #e9ecef;
        }

        .author-header {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .author-avatar {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: linear-gradient(135deg, #000, #333);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
            font-size: 1.2rem;
            flex-shrink: 0;
        }

        .author-info {
            flex: 1;
            min-width: 0;
        }

        .author-name {
            font-weight: 600;
            color: #333;
            font-size: 1.1rem;
            margin-bottom: 0.25rem;
        }

        .author-title {
            color: #666;
            font-size: 0.9rem;
            margin-bottom: 0.25rem;
        }

        .author-email {
            color: #666;
            font-size: 0.8rem;
            text-decoration: none;
        }

        .author-email:hover {
            color: #333;
        }

        .author-label {
            font-size: 0.8rem;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 0.5rem;
            font-weight: 600;
        }

        /* Stats Section Styling */
        .stats-section {
            background: white;
            border-radius: 12px;
            padding: 2rem;
            margin-bottom: 2rem;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }

        .stats-title {
            font-size: 1.5rem;
            font-weight: 600;
            color: #333;
            margin-bottom: 1.5rem;
            text-align: center;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 1rem;
            margin-bottom: 2rem;
        }

        .stat-card {
            text-align: center;
            padding: 1rem 0.5rem;
            background: #f8f9fa;
            border-radius: 8px;
            transition: all 0.3s ease;
            min-width: 0;
        }

        .stat-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 16px rgba(0,0,0,0.1);
        }

        .stat-number {
            font-size: 1.5rem;
            font-weight: 800;
            color: #333;
            margin-bottom: 0.25rem;
            line-height: 1;
        }

        .stat-label {
            font-size: 0.7rem;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            font-weight: 600;
            line-height: 1.2;
        }

        @media (max-width: 768px) {
            .stats-grid {
                grid-template-columns: repeat(3, 1fr);
                gap: 0.5rem;
            }
            
            .stat-card {
                padding: 0.75rem 0.25rem;
            }
            
            .stat-number {
                font-size: 1.2rem;
            }
            
            .stat-label {
                font-size: 0.6rem;
            }
        }

        @media (max-width: 480px) {
            .stats-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        .join-event-card {
            background: linear-gradient(135deg, #000, #333);
            color: white;
            text-align: center;
            padding: 2rem;
            border-radius: 12px;
            margin-top: 2rem;
        }

        .join-event-card h3 {
            margin-bottom: 1rem;
            font-size: 1.3rem;
        }

        .join-event-card p {
            margin-bottom: 1.5rem;
            opacity: 0.9;
            line-height: 1.6;
        }

        .btn {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 8px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            font-weight: 600;
        }

        .join-event-card .btn {
            background: white;
            color: #000;
        }

        .join-event-card .btn:hover {
            background: #f8f9fa;
            transform: translateY(-2px);
        }
        
        .join-event-card .btn.following {
            background: #28a745;
            color: white;
            border-color: #28a745;
        }
        
        .join-event-card .btn.following:hover {
            background: #218838;
            border-color: #1e7e34;
        }
        
        .join-event-card .manage-btn-stats {
            background: #dc3545;
            color: white;
            margin-left: 1rem;
        }
        
        .join-event-card .manage-btn-stats:hover {
            background: #c82333;
        }

        /* Event Feed Section */
        .event-feed-section {
            background: white;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
            padding: 2rem;
            margin-bottom: 2rem;
        }

        .feed-title {
            font-size: 1.8rem;
            font-weight: 700;
            color: #333;
            margin-bottom: 1.5rem;
        }

        /* Post Creation Box */
        .create-post-box {
            background: white;
            border: 2px solid #e5e5e5;
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 2rem;
            transition: border-color 0.3s ease;
        }

        .create-post-box:focus-within {
            border-color: #333;
        }

        .post-composer {
            display: flex;
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .composer-avatar {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            background: linear-gradient(135deg, #000, #333);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
            font-size: 0.9rem;
            flex-shrink: 0;
        }

        .composer-textarea {
            width: 100%;
            min-height: 100px;
            border: none;
            outline: none;
            resize: vertical;
            font-family: inherit;
            font-size: 1rem;
            line-height: 1.5;
            background: transparent;
            padding: 10px;
        }

        .composer-textarea::placeholder {
            color: #999;
        }

        .composer-actions {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-top: 1rem;
            border-top: 1px solid #f0f0f0;
        }

        .upload-buttons {
            display: flex;
            gap: 1rem;
        }

        .upload-btn {
            background: #f8f9fa;
            border: 1px solid #e5e5e5;
            border-radius: 6px;
            padding: 0.5rem 1rem;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.3s ease;
        }

        .upload-btn:hover {
            background: #e9ecef;
            border-color: #333;
        }

        .post-controls {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .character-count {
            color: #666;
            font-size: 0.8rem;
        }

        .post-btn {
            background: #333;
            color: white;
            border: none;
            border-radius: 6px;
            padding: 0.6rem 1.5rem;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .post-btn:hover {
            background: #000;
        }

        .post-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .main-container {
            max-width: 1200px;
            margin: 2rem auto;
            padding: 0 2rem;
            min-height: calc(100vh - 200px);
        }

        @media (max-width: 768px) {
            .nav-menu {
                display: none;
            }
            
            .event-hero {
                height: 300px;
            }
            
            .hero-content {
                flex-direction: column;
                align-items: center;
                text-align: center;
                padding: 2rem;
                gap: 1rem;
            }

            .hero-title {
                font-size: 2rem !important;
            }

            .hero-subtitle {
                font-size: 1rem !important;
            }
            
            .main-container {
                padding: 0 1rem;
            }

            .about-content {
                grid-template-columns: 1fr;
            }

            /* Two column layout becomes single column on mobile */
            .main-container > div[style*="grid-template-columns"] {
                display: block !important;
            }

            .main-container > div[style*="grid-template-columns"] > div:first-child {
                margin-bottom: 2rem;
            }
        }

        /* Posts Section - Added from member profile */
        .posts-section {
            padding: 2rem;
        }

        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
        }

        .section-title {
            font-size: 1.5rem;
            font-weight: 600;
            color: #333;
        }

        .post-count {
            color: #666;
            font-size: 0.9rem;
            font-weight: normal;
        }

        .post-card {
            background: white;
            border: 1px solid #e5e5e5;
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            transition: all 0.3s ease;
        }

        .post-card:hover {
            border-color: #333;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .post-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            padding-bottom: 0.75rem;
            border-bottom: 1px solid #f0f0f0;
        }

        .post-author {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .post-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(135deg, #000, #333);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
            font-size: 0.9rem;
        }

        .post-author-info h4 {
            margin: 0;
            font-size: 1rem;
            font-weight: 600;
            color: #333;
        }

        .post-date {
            color: #666;
            font-size: 0.85rem;
        }

        .post-content {
            color: #555;
            line-height: 1.6;
            font-size: 1rem;
            white-space: pre-wrap;
            margin-bottom: 1rem;
        }

        .post-actions {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 1rem;
            padding-top: 0.75rem;
            border-top: 1px solid #f0f0f0;
        }

        .post-stats {
            display: flex;
            gap: 1rem;
            color: #666;
            font-size: 0.9rem;
        }

        .post-actions-btns {
            display: flex;
            gap: 0.5rem;
        }

        .post-action-btn {
            background: none;
            border: 1px solid #e5e5e5;
            padding: 0.5rem 1rem;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.85rem;
            color: #666;
            transition: all 0.3s ease;
        }

        .post-action-btn:hover {
            background: #f8f9fa;
            color: #333;
            border-color: #333;
        }

        .loading-post {
            text-align: center;
            color: #666;
            font-style: italic;
            opacity: 0.7;
        }

        .no-posts {
            text-align: center;
            padding: 3rem;
            color: #666;
        }

        .no-posts h3 {
            color: #333;
            margin-bottom: 1rem;
        }

        /* Post Creation Styles */
        .create-post-box {
            background: white;
            border-radius: 12px;
            padding: 1rem;
            margin-bottom: 1.5rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            border: 1px solid #e5e5e5;
            position: sticky;
            top: 0;
            z-index: 50;
        }

        .post-author-info {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 0.75rem;
        }

        .create-post-box .author-avatar {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            background: linear-gradient(135deg, #000, #333);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
            background-size: cover;
            background-position: center;
        }

        .create-post-box .author-name {
            font-weight: 600;
            color: #333;
            font-size: 1rem;
        }

        .post-textarea {
            width: 100%;
            min-height: 50px;
            padding: 0.75rem;
            border: 1px solid #e5e5e5;
            border-radius: 8px;
            font-size: 1rem;
            resize: vertical;
            font-family: inherit;
            outline: none;
            margin-bottom: 0.5rem;
        }

        .post-textarea:focus {
            border-color: #333;
        }

        .post-actions {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .media-btn, .post-btn-disabled {
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 6px;
            font-size: 0.9rem;
            cursor: pointer;
            font-weight: 500;
        }

        .media-btn {
            background: #f8f9fa;
            color: #666;
            border: 1px solid #e5e5e5;
        }

        .media-btn:hover {
            background: #e9ecef;
        }

        .post-btn {
            background: #000 !important;
            color: white !important;
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 6px;
            font-size: 0.9rem;
            cursor: pointer;
            font-weight: 500;
        }

        .post-btn:hover {
            background: #333 !important;
        }

        .post-btn:disabled {
            background: #e5e5e5 !important;
            color: #999 !important;
            cursor: not-allowed;
        }

        .post-btn-disabled {
            background: #e5e5e5;
            color: #999;
            cursor: not-allowed;
        }

        .post-actions-expanded {
            margin-top: 0;
        }

        .media-preview-area {
            min-height: 100px;
            border: 2px dashed #e5e5e5;
            border-radius: 8px;
            display: none;
            margin-bottom: 1rem;
            padding: 1rem;
            text-align: center;
            color: #666;
        }

        .post-toolbar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            padding: 0.5rem 0;
            border-top: 1px solid #f0f0f0;
            border-bottom: 1px solid #f0f0f0;
        }

        .post-submit-area {
            display: flex;
            justify-content: flex-end;
        }

        .character-count {
            font-size: 0.8rem;
            color: #666;
        }

        .posts-feed {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }

        .loading-posts {
            text-align: center;
            padding: 2rem;
            color: #666;
        }

        .post-content a {
            color: #007bff;
            text-decoration: underline;
            word-break: break-word;
            transition: color 0.2s ease;
        }

        .post-content a:hover {
            color: #0056b3;
            text-decoration: none;
        }

        .post-content a:visited {
            color: #6f42c1;
        }

        .liked {
            color: #007bff !important;
            font-weight: 600 !important;
        }
        
        /* Professional Comments Section Styling - COMPLETE */
        .comments-section {
            margin-top: 1.5rem !important;
            border-top: 1px solid #f0f0f0 !important;
            padding-top: 1rem !important;
            background: #fafbfc !important;
            border-radius: 12px !important;
            padding: 1.5rem !important;
            box-shadow: 0 2px 8px rgba(0,0,0,0.04) !important;
        }

        .section-title {
            font-size: 1rem !important;
            font-weight: 600 !important;
            color: #333 !important;
            margin-bottom: 1rem !important;
        }

        /* Comment Containers */
        .comment-container {
            background: white !important;
            border-radius: 12px !important;
            padding: 1.25rem !important;
            margin-bottom: 1rem !important;
            border: 1px solid #e8ecef !important;
            box-shadow: 0 2px 4px rgba(0,0,0,0.06) !important;
            transition: all 0.2s ease !important;
        }

        .comment-container:hover {
            border-color: #d0d7de !important;
            box-shadow: 0 4px 12px rgba(0,0,0,0.08) !important;
        }

        /* Reply Containers */
        .reply-container {
            background: #f8f9fa !important;
            border-left: 3px solid #007bff !important;
            border-radius: 8px !important;
            margin: 0.75rem 0 0.75rem 2.5rem !important;
            padding: 1rem !important;
            border: 1px solid #e8ecef !important;
        }

        /* Comment Author Styles */
        .comment-author {
            font-weight: 600 !important;
            color: #2c3e50 !important;
            font-size: 0.85rem !important;
            margin-right: 0.5rem !important;
        }

        .comment-date {
            color: #7f8c8d !important;
            font-size: 0.75rem !important;
        }

        .comment-content {
            color: #2c3e50 !important;
            font-size: 0.9rem !important;
            line-height: 1.5 !important;
            margin-top: 0.5rem !important;
            word-wrap: break-word !important;
        }

        /* Professional Comment Form Styling */
        .comment-form {
            background: white !important;
            border-radius: 12px !important;
            padding: 1rem !important;
            border: 1px solid #e8ecef !important;
            box-shadow: 0 2px 4px rgba(0,0,0,0.04) !important;
            margin-bottom: 1rem !important;
        }

        .comment-textarea {
            width: 100% !important;
            min-height: 80px !important;
            padding: 0.75rem !important;
            border: 2px solid #e1e5e9 !important;
            border-radius: 8px !important;
            font-size: 0.9rem !important;
            resize: vertical !important;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif !important;
            margin-bottom: 0.5rem !important;
            transition: border-color 0.3s ease !important;
            line-height: 1.5 !important;
        }

        .comment-textarea:focus {
            border-color: #007bff !important;
            outline: none !important;
            box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.1) !important;
        }

        .comment-textarea:disabled {
            background: #f5f5f5 !important;
            cursor: not-allowed !important;
            opacity: 0.6 !important;
        }

        .comment-submit-btn {
            background: #007bff !important;
            color: white !important;
            border: none !important;
            padding: 0.5rem 1rem !important;
            border-radius: 6px !important;
            font-size: 0.85rem !important;
            cursor: pointer !important;
            font-weight: 500 !important;
            transition: all 0.2s ease !important;
            box-shadow: 0 1px 3px rgba(0,123,255,0.2) !important;
        }

        .comment-submit-btn:hover:not(:disabled) {
            background: #0056b3 !important;
            transform: translateY(-1px) !important;
            box-shadow: 0 3px 6px rgba(0,123,255,0.3) !important;
        }

        .comment-submit-btn:disabled {
            opacity: 0.5 !important;
            cursor: not-allowed !important;
            box-shadow: none !important;
        }

        .comment-actions button {
            transition: all 0.2s ease;
        }

        .comment-actions button:hover {
            opacity: 0.8;
            transform: translateY(-1px);
        }

        .comment-actions button svg {
            vertical-align: middle;
        }

        .reply-container {
            border-left: 2px solid #e5e5e5;
            padding-left: 1rem;
        }

        /* Enhanced Comment Action Buttons */
        .comment-action-btn {
            background: #f8f9fa !important;
            border: 1px solid #e1e5e9 !important;
            color: #656d76 !important;
            padding: 0.5rem 0.75rem !important;
            border-radius: 6px !important;
            font-size: 0.8rem !important;
            cursor: pointer !important;
            transition: all 0.2s ease !important;
            display: inline-flex !important;
            align-items: center !important;
            gap: 0.25rem !important;
            font-weight: 500 !important;
        }

        .comment-action-btn:hover {
            background: #e9ecef !important;
            border-color: #adb5bd !important;
            color: #495057 !important;
            transform: translateY(-1px) !important;
        }

        .comment-container .comment-action-btn {
            background: #f8f9fa !important;
            border: 1px solid #e1e5e9 !important;
            color: #656d76 !important;
            padding: 0.5rem 0.75rem !important;
            border-radius: 6px !important;
            font-size: 0.8rem !important;
        }

        .comment-action-btn.liked {
            background: #e3f2fd !important;
            border-color: #2196f3 !important;
            color: #1976d2 !important;
        }

        .comment-action-btn.delete-btn {
            color: #dc3545 !important;
            border-color: #f8d7da !important;
        }

        .comment-action-btn.delete-btn:hover {
            background: #f8d7da !important;
            color: #721c24 !important;
            border-color: #dc3545 !important;
        }

        /* Sort buttons styling */
        .sort-btn {
            transition: all 0.2s ease !important;
            font-weight: 500 !important;
        }

        .sort-btn:hover:not(.active) {
            background: #e9ecef !important;
            transform: translateY(-1px) !important;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1) !important;
        }

        .sort-btn.active {
            cursor: default !important;
            box-shadow: 0 1px 3px rgba(0,0,0,0.15) !important;
        }

        /* Comment Avatar Styles */
        .comment-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea, #764ba2); /* Default gradient like working avatars */
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
            font-size: 0.8rem;
            flex-shrink: 0;
            background-size: cover;
            background-position: center;
        }

        /* Reply Form Styles */
        .reply-form {
            display: none;
            margin-top: 0.5rem !important;
            padding: 0.5rem !important;
            background: #f8f9fa !important;
            border-radius: 6px !important;
            border: 1px solid #e9ecef !important;
        }

        .reply-textarea {
            width: 100% !important;
            min-height: 60px !important;
            padding: 0.5rem !important;
            border: 1px solid #dee2e6 !important;
            border-radius: 4px !important;
            font-size: 0.8rem !important;
            resize: vertical !important;
            font-family: inherit !important;
        }

        /* Comment List Styling */
        #commentsList {
            min-height: 50px !important;
        }

        /* Empty State */
        .comments-empty {
            color: #666 !important;
            font-size: 0.9rem !important;
            font-style: italic !important;
            text-align: center !important;
            padding: 1rem !important;
        }

        /* Helper Text */
        .comment-helper-text {
            font-size: 0.8rem !important;
            color: #666 !important;
            margin-top: 0.25rem !important;
        }
    </style>
</head>

<body>
    <header class="header">
        <nav class="nav-container">
            <a href="../index.html" class="logo">
                <div class="logo-icon"></div>
                Domus Communis Foundation
            </a>
             <ul class="nav-menu" id="navMenu">
                <!-- Navigation populated by dcf-unified-auth.js -->
            </ul>
            <div class="user-menu">
                <div class="user-dropdown">
                    <div class="user-avatar" onclick="toggleUserMenu()" id="userAvatar"></div>
                    <div class="dropdown-menu" id="userDropdown">
                        <div class="dropdown-header">
                            <div class="dropdown-avatar"></div>
                            <div class="dropdown-info">
                                <div class="dropdown-name" id="dropdownUserName"></div>
                                <div class="dropdown-email" id="dropdownUserEmail"></div>
                            </div>
                        </div>
                        <div class="dropdown-divider"></div>
                    </div>
                </div>
            </div>
        </nav>
    </header>

    <main class="main-container">
        <!-- Event Cover Photo with Overlay -->
        <div class="event-hero" id="eventHero">
            <div class="hero-background" id="heroBackground"></div>
            <div class="hero-overlay"></div>
            
            <!-- Edit Cover Button (hidden by default) -->
            <button type="button" class="edit-cover-btn" id="editCoverBtn" style="display: none;">
                <span>📷</span> Edit Cover
            </button>
            
            <!-- Cover Position Controls (hidden by default) -->
            <div class="cover-position-controls" id="coverPositionControls" style="display: none;">
                <div class="position-info">Drag image or use controls to adjust vertical position</div>
                <div class="position-slider-container">
                    <button class="position-btn" onclick="adjustCoverPosition(-5)" title="Move Up">↑</button>
                    <input type="range" id="positionSlider" min="0" max="100" value="50" oninput="setCoverPosition(this.value)">
                    <button class="position-btn" onclick="adjustCoverPosition(5)" title="Move Down">↓</button>
                </div>
                <div class="position-actions">
                    <button class="save-position-btn" onclick="saveCoverPosition()">Save Position</button>
                    <button class="cancel-position-btn" onclick="cancelRepositioning()">Cancel</button>
                </div>
            </div>
            
            <div class="hero-content">
                <h1 class="hero-title" id="heroTitle">Title Goes Here</h1>
                <p class="hero-subtitle" id="heroSubtitle">Event Date and Time Goes Here</p>
                <a href="#" class="event-website-link" id="eventWebsiteLink" target="_blank" style="display: none; color: white; margin-top: 1rem;">Visit Event Website</a>
                
                <!-- Owner Controls -->
                <div class="owner-controls" id="ownerControls" style="display: none;">
                    <button class="manage-event-btn" onclick="manageEvent()">
                        <span>⚙️</span> Manage Event
                    </button>
                </div>
            </div>
        </div>

        <!-- About Section -->
        <div class="about-section" id="aboutSection">
            <div class="about-content">
                <!-- Left Column -->
                <div>
                    <h2 class="about-title" id="aboutTitle">About This Event</h2>
                    <a href="#" class="event-url-link" id="eventUrlLink" target="_blank" style="display: none;">Visit Event Website</a>
                    <div class="about-description" id="aboutDescription">
                        <p>Event description will appear here. This section provides detailed information about the event's purpose, agenda, and what to expect.</p>
                        
                        <!-- Like/Share Actions -->
                        <div class="event-actions" style="margin-top: 1.5rem; display: flex; gap: 1rem;">
                            <button class="interaction-btn" id="likeBtn" onclick="toggleLike()" style="transition: all 0.3s ease;">
                                <span style="transition: transform 0.3s ease;">🤍</span>
                                <span id="likeText">Like</span>
                                <span id="likeCount" style="margin-left: 0.25rem;">(0)</span>
                            </button>
                            <div class="share-dropdown">
                                <button class="interaction-btn" onclick="toggleShareMenu()">
                                    <span>📤</span>
                                    <span>Share</span>
                                </button>
                                <div class="share-menu" id="shareMenu">
                                    <div class="share-item" onclick="copyLink()">
                                        <span>🔗</span>
                                        <span>Copy Link</span>
                                    </div>
                                    <div class="share-item" onclick="shareEmail()">
                                        <span>📧</span>
                                        <span>Share via Email</span>
                                    </div>
                                    <div class="share-item" onclick="shareTwitter()">
                                        <span>🐦</span>
                                        <span>Share on Twitter</span>
                                    </div>
                                    <div class="share-item" onclick="shareLinkedIn()">
                                        <span>💼</span>
                                        <span>Share on LinkedIn</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Right Column Container -->
                <div class="right-column">
                    <!-- Event Organizer Card -->
                    <div class="author-card" id="authorCard">
                        <div class="author-label">Event Organizer</div>
                        <div class="author-header">
                            <div class="author-avatar" id="authorAvatar"></div>
                            <div class="author-info">
                                <div class="author-name" id="authorName"></div>
                                <div class="author-title" id="authorTitle"></div>
                                <a href="mailto:" class="author-email" id="authorEmail"></a>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Related Events Card -->
                    <div class="author-card" id="relatedEventsCard" style="margin-top: 2rem;">
                        <div class="author-label">Related Events</div>
                        <div id="relatedEventsList" style="margin-top: 1rem;">
                            <!-- Related events will be loaded here -->
                            <div style="color: #666; font-size: 0.9rem;">Loading related events...</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Stats Section -->
        <div class="stats-section" id="statsSection">
            <h3 class="stats-title" id="statsTitle">Event Statistics</h3>
            <div class="stats-grid" id="statsGrid">
                <div class="stat-card">
                    <div class="stat-number" id="statRegistered">...</div>
                    <div class="stat-label">Registered</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="statSpots">...</div>
                    <div class="stat-label">Spots Left</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="statWaitlist">...</div>
                    <div class="stat-label">Waitlist</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="statResources">...</div>
                    <div class="stat-label">Resources</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="statViews">...</div>
                    <div class="stat-label">Views</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="statShares">...</div>
                    <div class="stat-label">Shares</div>
                </div>
            </div>

            <!-- Join Event Card -->
            <div class="join-event-card" id="joinEventCard">
                <h3 id="joinCardTitle">Register for This Event</h3>
                <p id="joinCardDescription">Reserve your spot and receive event updates</p>
                <button class="btn" id="joinEventBtn" onclick="handleJoinEvent()">📝 Register Now</button>
                <button class="btn manage-btn-stats" id="manageEventBtn" onclick="manageEvent()" style="display: none;">⚙️ Manage Event</button>
            </div>
        </div>

        <!-- Two Column Layout -->
        <div style="display: grid; grid-template-columns: 300px 1fr; gap: 2rem;">
            <!-- Left Sidebar -->
            <div style="display: flex; flex-direction: column; gap: 1.5rem;">
                <div style="background: white; border-radius: 12px; padding: 1.5rem; box-shadow: 0 2px 8px rgba(0,0,0,0.05);">
                    <h3 style="font-size: 1.1rem; font-weight: 600; color: #333; margin-bottom: 1rem;">Quick Actions</h3>
                    <div id="quickActionsContainer">
                        <!-- Populated by dcf-unified-auth.js -->
                    </div>
                </div>

                <div style="background: white; border-radius: 12px; padding: 1.5rem; box-shadow: 0 2px 8px rgba(0,0,0,0.05);">
                    <h3 style="font-size: 1.1rem; font-weight: 600; color: #333; margin-bottom: 1rem;">Event Details</h3>
                    <div style="color: #666; font-size: 0.9rem; line-height: 1.6;">
                        <p><strong>Status:</strong> Active</p>
                        <p><strong>Created:</strong> 2 weeks ago</p>
                        <p><strong>Duration:</strong> 2 hours</p>
                        <p><strong>Priority:</strong> High</p>
                    </div>
                </div>
            </div>

            <!-- Right Main Content - Event Feed -->
            <div class="event-feed-section">
                <h2 class="feed-title" id="eventFeedTitle">Event Announcements</h2>
                
                <!-- Create Announcement Box (for organizers only) -->
                <div class="create-post-box" data-requires-post-permission="true" style="display: none;" id="createAnnouncementBox">
                    <div class="post-author-info">
                        <div class="author-avatar" id="postAuthorAvatar" style="background: linear-gradient(135deg, #e5e5e5, #cacaca); color: #999; display: flex; align-items: center; justify-content: center; font-weight: 600;"></div>
                        <div class="author-details">
                            <div class="author-name" id="postAuthorName" style="color: #999;"></div>
                        </div>
                    </div>
                    
                    <div class="post-content-area">
                        <textarea 
                            class="post-textarea" 
                            id="postTextarea"
                            placeholder="Share event updates, announcements, or ask attendees a question..."
                            maxlength="2000"
                        ></textarea>
                    </div>
                    
                    <div id="postFilePreview"></div>
                    
                    <div class="post-actions-expanded">
                        <div style="display: flex; justify-content: space-between; align-items: center; padding: 0.5rem 0;">
                            <!-- Left side: Media button -->
                            <button type="button" onclick="document.getElementById('mediaFileInput').click()" style="background: none; border: none; color: #666; cursor: pointer; padding: 0.25rem 0.5rem; border-radius: 6px; transition: background 0.2s ease; font-size: 0.9rem;">
                                📷 <span style="margin-left: 0.25rem;">Photo</span>
                            </button>
                            
                            <!-- Right side: Character count and Post button -->
                            <div style="display: flex; align-items: center; gap: 1rem;">
                                <span style="font-size: 0.8rem; color: #666;" id="characterCount">0/2000</span>
                                <button class="post-btn" id="postSubmitBtnExpanded" onclick="submitPost()" disabled style="padding: 0.5rem 1.25rem; font-size: 0.9rem;">Post</button>
                            </div>
                        </div>
                    </div>
                </div>
                
                <input type="file" id="mediaFileInput" style="display: none;" accept="image/*,video/*" multiple>
                <div id="postUploadProgress" style="display: none; width: 100%; height: 8px; background: #e5e5e5; border-radius: 4px; margin-top: 1rem; overflow: hidden;">
                    <div id="postUploadProgressFill" style="height: 100%; background: linear-gradient(90deg, #000, #333); border-radius: 4px; width: 0%; transition: width 0.3s ease;"></div>
                </div>
                <div id="postUploadStatus" style="display: none; margin-top: 0.5rem; font-size: 0.9rem; color: #666;"></div>
                
                <!-- Posts Feed -->
                <div class="posts-feed" id="postsFeed">
                    <div class="loading-posts">Loading posts...</div>
                </div>
            </div>
        </div>
    </main>

    <!-- Cover Edit Modal -->
    <div class="cover-modal" id="coverEditModal">
        <div class="cover-modal-content">
            <div class="cover-modal-header">
                <h3>Change Cover Photo</h3>
                <button class="close-modal" onclick="closeCoverEditModal()">✕</button>
            </div>
            <div class="cover-modal-body">
                <div class="upload-area" id="uploadArea">
                    <input type="file" id="coverImageInput" accept="image/*" style="display: none;" onchange="previewCoverImage(event)">
                    <div class="upload-placeholder" onclick="document.getElementById('coverImageInput').click()">
                        <span style="font-size: 3rem;">📷</span>
                        <p>Click to upload a new cover photo</p>
                        <p style="font-size: 0.9rem; color: #666;">Recommended size: 1920x350px</p>
                    </div>
                    <img class="image-preview" id="coverImagePreview" style="display: none;">
                </div>
                <div style="margin-top: 1.5rem; text-align: center; border-top: 1px solid #e5e5e5; padding-top: 1.5rem;">
                    <p style="margin-bottom: 1rem; color: #666;">Or adjust the current cover photo:</p>
                    <button class="btn-save" onclick="startRepositionMode()" style="background: #6c757d;">
                        Reposition Current Photo
                    </button>
                </div>
            </div>
            <div class="cover-modal-footer">
                <button class="btn-cancel" onclick="closeCoverEditModal()">Cancel</button>
                <button class="btn-save" onclick="saveCoverImage()" id="saveCoverBtn" disabled>Save Cover Photo</button>
            </div>
        </div>
    </div>

    <script>
        // Get event ID from URL
        function getEventIdFromUrl() {
            const urlParams = new URLSearchParams(window.location.search);
            const eventId = urlParams.get('id');
            
            // Validate event ID
            if (!eventId) {
                console.error('No event ID found in URL');
                showEventNotFoundError();
                return null;
            }
            
            // Check if it's a valid UUID format
            const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
            if (!uuidRegex.test(eventId)) {
                console.error('Invalid event ID format:', eventId);
                showEventNotFoundError();
                return null;
            }
            
            return eventId;
        }
        
        // Alias for consistency (some parts of code use this name)
        function getEventIdFromURL() {
            return getEventIdFromUrl();
        }
        
        // Show error when event ID is missing or invalid
        function showEventNotFoundError() {
            const container = document.querySelector('.hero-section');
            if (container) {
                container.innerHTML = `
                    <div style="text-align: center; padding: 4rem 2rem;">
                        <h2 style="color: #dc3545; margin-bottom: 1rem;">Event Not Found</h2>
                        <p style="color: #666; margin-bottom: 2rem;">The event you're looking for doesn't exist or the URL is invalid.</p>
                        <a href="dcf_events_calendar.html" class="btn btn-primary">Browse Events</a>
                    </div>
                `;
            }
        }

        // Load event data
        async function loadEvent() {
            const eventId = getEventIdFromUrl();
            
            if (!eventId) {
                console.error('No event ID found in URL');
                return;
            }

            if (!window.dcfSupabase) {
                console.error('Supabase client not available');
                return;
            }

            try {
                console.log('📥 Loading event with ID:', eventId);
                
                const { data: event, error } = await window.dcfSupabase
                    .from('events')
                    .select(`*, author:user_profiles!author_id(id,email,username,first_name,last_name,avatar_url)`)
                    .eq('id', eventId)
                    .single();

                if (error || !event) {
                    console.error('Error loading event:', error);
                    return;
                }

                // Comprehensive project data logging
                console.log('');
                console.log('📋 EVENT DATA LOADED:');
                console.log('Full event object:', event);
                console.log('Event ID:', event.id);
                console.log('Event author_id:', event.author_id);
                console.log('Author_id type:', typeof event.author_id);
                console.log('Event author object:', event.author);
                if (event.author) {
                    console.log('  Author.id:', event.author.id);
                    console.log('  Author.id type:', typeof event.author.id);
                    console.log('  Author.email:', event.author.email);
                    console.log('  Author.username:', event.author.username);
                }
                console.log('');

                displayEvent(event);
                loadRelatedEvents(event.author_id, eventId);
                
                // Track project view using Universal Analytics System (only once)
                if (window.trackInteraction && !window.eventViewTracked) {
                    window.eventViewTracked = true; // Set flag to prevent duplicate tracking
                    window.trackInteraction('event', eventId, 'view', {
                        title: event.title || 'Event',
                        author_id: event.author_id
                    });
                } else if (!window.trackInteraction) {
                    console.log('View tracking not available yet');
                } else {
                    console.log('View already tracked for this event');
                }
                
            } catch (error) {
                console.error('Error loading event:', error);
            }
        }
        
        // Load related events by same organizer
        async function loadRelatedEvents(authorId, currentEventId) {
            if (!authorId || !window.dcfSupabase) return;
            
            try {
                const { data: relatedEvents, error } = await window.dcfSupabase
                    .from('events')
                    .select('id, title, description, event_date')
                    .eq('author_id', authorId)
                    .neq('id', currentEventId)
                    .limit(2);  // Changed from 3 to 2
                    
                const container = document.getElementById('relatedEventsList');
                if (!container) return;
                
                if (error || !relatedEvents || relatedEvents.length === 0) {
                    container.innerHTML = '<div style="color: #666; font-size: 0.9rem;">No other events by this organizer</div>';
                    return;
                }
                
                container.innerHTML = relatedEvents.map(event => {
                    const truncatedDesc = event.description ? 
                        (event.description.length > 100 ? 
                            event.description.substring(0, 100) + '...' : 
                            event.description) : 'No description available';
                            
                    return `
                        <div class="related-event-item" onclick="window.location.href='test.html?id=${event.id}'">
                            <div class="related-event-title">${event.title}</div>
                            <div class="related-event-desc">${truncatedDesc}</div>
                        </div>
                    `;
                }).join('');
                
                // Add More button at the bottom
                container.innerHTML += `
                    <button class="related-events-more-btn" onclick="window.location.href='dcf_events_calendar.html'">
                        More Events →
                    </button>
                `;
                
            } catch (error) {
                console.error('Error loading related projects:', error);
                const container = document.getElementById('relatedEventsList');
                if (container) {
                    container.innerHTML = '<div style="color: #666; font-size: 0.9rem;">Error loading related projects</div>';
                }
            }
        }

        // Display event data
        async function displayEvent(event) {
            // Store event globally
            window.currentEvent = event;
            
            // Enhanced debugging for ownership detection
            console.log('=== OWNERSHIP DETECTION DEBUG ===');
            console.log('1. Getting current user...');
            
            // Try multiple methods to get current user
            const currentUser = window.getCurrentUser ? window.getCurrentUser() : null;
            let sessionUserId = null;
            let sessionUserEmail = null;
            
            // Also get direct from Supabase session as fallback
            if (window.dcfSupabase) {
                try {
                    const { data: { session } } = await window.dcfSupabase.auth.getSession();
                    if (session) {
                        sessionUserId = session.user.id;
                        sessionUserEmail = session.user.email;
                    }
                } catch (e) {
                    console.error('Error getting session:', e);
                }
            }
            
            console.log('2. Current User Object:', currentUser);
            console.log('3. Session User ID:', sessionUserId);
            console.log('4. Session User Email:', sessionUserEmail);
            console.log('5. Event Organizer ID:', event.author_id);
            console.log('6. Event Organizer Object:', event.author);
            
            // Try all possible ownership checks
            const checks = {
                profileIdMatch: currentUser && currentUser.id === event.author_id,
                sessionIdMatch: sessionUserId && sessionUserId === event.author_id,
                profileEmailMatch: currentUser && event.author && currentUser.email === event.author.email,
                sessionEmailMatch: sessionUserEmail && event.author && sessionUserEmail === event.author.email,
                caseInsensitiveEmail: (currentUser?.email?.toLowerCase() === event.author?.email?.toLowerCase()) ||
                                     (sessionUserEmail?.toLowerCase() === event.author?.email?.toLowerCase())
            };
            
            console.log('7. Ownership checks:', checks);
            
            // If ANY check passes, user is owner
            const isOwner = Object.values(checks).some(check => check === true);
            
            console.log('8. FINAL OWNERSHIP RESULT:', isOwner);
            console.log('=== END DEBUG ===');
            
            if (isOwner) {
                // Show edit cover button
                const editCoverBtn = document.getElementById('editCoverBtn');
                if (editCoverBtn) {
                    editCoverBtn.style.display = 'flex';
                    console.log('✅ Showing edit cover button for project owner');
                }
                
                // Show owner controls (Manage Project button)
                const ownerControls = document.getElementById('ownerControls');
                if (ownerControls) {
                    ownerControls.style.display = 'flex';
                    console.log('✅ Showing owner controls for project owner');
                }
                
                // Also update the stats section buttons
                const joinBtn = document.getElementById('joinEventBtn');
                const manageBtn = document.getElementById('manageProjectBtn');
                if (joinBtn) joinBtn.style.display = 'none';
                if (manageBtn) manageBtn.style.display = 'inline-flex';
            } else {
                console.log('❌ User is not the event organizer - controls remain hidden');
                console.log('💡 TIP: You can run forceShowOwnerControls() in console to test owner features');
            }
            
            // Set hero section with event-specific information
            if (event.main_photo_url) {
                setHeroBackground(event.main_photo_url);
            }
            
            // Format event date and time
            const eventDate = event.event_date ? new Date(event.event_date).toLocaleDateString('en-US', {
                weekday: 'long',
                year: 'numeric',
                month: 'long',
                day: 'numeric'
            }) : 'Date TBD';
            const eventTime = event.event_time || 'Time TBD';
            const eventDateTime = `${eventDate} at ${eventTime}`;
            
            setHeroTitle(event.title, eventDateTime);
            
            // Handle website link in hero section and About section
            const websiteLink = document.getElementById('eventWebsiteLink');
            const aboutUrlLink = document.getElementById('eventUrlLink');
            
            if (event.website_url) {
                if (websiteLink) {
                    websiteLink.href = event.website_url;
                    websiteLink.style.display = 'inline-block';
                }
                
                if (aboutUrlLink) {
                    aboutUrlLink.href = event.website_url;
                    aboutUrlLink.textContent = 'Visit Event Website';
                    aboutUrlLink.style.display = 'inline-block';
                }
            } else {
                // Show fallback text when no URL is available
                if (aboutUrlLink) {
                    aboutUrlLink.removeAttribute('href');
                    aboutUrlLink.textContent = 'Event URL goes here';
                    aboutUrlLink.style.display = 'inline-block';
                    aboutUrlLink.style.color = '#999';
                    aboutUrlLink.style.cursor = 'default';
                    aboutUrlLink.style.textDecoration = 'none';
                }
            }
            
            // Set about section with event details
            let eventDetailsHtml = `
                <div style="margin-bottom: 1.5rem;">
                    <h3 style="font-size: 1.1rem; margin-bottom: 0.75rem; color: #333;">Event Details</h3>
                    <div style="display: grid; gap: 0.75rem; color: #666;">
                        <div><strong>📅 Date:</strong> ${eventDate}</div>
                        <div><strong>🕐 Time:</strong> ${eventTime}</div>
                        <div><strong>📍 Location:</strong> ${event.location || 'Location TBD'}</div>
                        <div><strong>🎯 Format:</strong> ${event.event_format || 'In-Person'}</div>
                        <div><strong>👥 Capacity:</strong> ${event.max_attendees || 'Unlimited'} attendees</div>
                        ${event.registration_deadline ? `<div><strong>⏰ Registration Deadline:</strong> ${new Date(event.registration_deadline).toLocaleDateString()}</div>` : ''}
                    </div>
                </div>
            `;
            
            const primaryDescription = event.description || '';
            const expandedDescription = event.full_description || '';
            setAboutContent(`About This Event`, eventDetailsHtml + primaryDescription, expandedDescription, null);
            
            // Set author details using unified auth system instead of raw database data
            if (event.author) {
                const currentUser = window.getCurrentUser ? window.getCurrentUser() : null;
                
                // Check if the current user is the project author
                if (currentUser && currentUser.id === event.author_id) {
                    // Use unified auth data for current user
                    setAuthorDetails(
                        `@${currentUser.username}`,
                        'Event Organizer',
                        null, // Never show email
                        generateInitials(currentUser.username),
                        currentUser.avatar_url
                    );
                } else {
                    // For other users, use only safe public data
                    const username = event.author?.username || 'Unknown User';
                    setAuthorDetails(
                        `@${username}`,
                        'Event Organizer', 
                        null, // Never show email
                        generateInitials(username),
                        event.author?.avatar_url
                    );
                }
            }
            
            // Load real statistics from database
            await loadEventStatistics(event.id);
            
            // Check user permissions and update UI accordingly
            await updateUIBasedOnPermissions(event.id);
            
            // Check if current user is the project author and show appropriate buttons
            updateProjectButtons(project);
            
            // Check follow status for the current user
            checkFollowStatus();
            
            // Update page title
            document.title = `${project.title} - DCF Hungary`;
            
            // Update feed title to show project name
            const feedTitle = document.getElementById('eventFeedTitle');
            if (feedTitle) {
                feedTitle.textContent = `${project.title} Feed`;
            }
        }

        // Function to update project buttons based on user ownership
        function updateProjectButtons(project) {
            const joinBtn = document.getElementById('joinEventBtn');
            const manageBtn = document.getElementById('manageProjectBtn');
            const currentUser = window.getCurrentUser ? window.getCurrentUser() : null;
            
            console.log('=== UPDATE PROJECT BUTTONS DEBUG ===');
            console.log('Current User:', currentUser);
            console.log('Project Author ID:', event.author_id);
            
            // Try multiple ownership checks
            const isOwnerById = currentUser && currentUser.id === event.author_id;
            const isOwnerByEmail = currentUser && event.author && currentUser.email === event.author.email;
            const isOwner = isOwnerById || isOwnerByEmail;
            
            console.log('Ownership by ID:', isOwnerById);
            console.log('Ownership by email:', isOwnerByEmail);
            console.log('Final ownership:', isOwner);
            
            if (isOwner) {
                // User is the project owner - show manage button, hide join button
                if (joinBtn) joinBtn.style.display = 'none';
                if (manageBtn) manageBtn.style.display = 'inline-flex';
                console.log('✅ Showing manage button for project owner');
            } else {
                // User is not the owner - show join button, hide manage button  
                if (joinBtn) joinBtn.style.display = 'inline-flex';
                if (manageBtn) manageBtn.style.display = 'none';
                console.log('❌ Showing join button for non-owner');
            }
            console.log('=== END BUTTON DEBUG ===')
        }

        // Function to handle manage project
        function manageEvent() {
            const eventId = getEventIdFromUrl();
            if (eventId) {
                window.location.href = `dcf_event_manage.html?id=${eventId}`;
            }
            }

        // Generate initials from name
        function generateInitials(name) {
            if (!name || typeof name !== 'string') return 'U';
            
            const cleanName = name.replace(/^(Dr\.?|Mr\.?|Mrs\.?|Ms\.?|Prof\.?|Professor|Father|Fr\.?|Sister|Sr\.?|Rabbi)\s+/i, '').trim();
            const parts = cleanName.split(' ').filter(part => part.length > 0);
            
            if (parts.length >= 2) {
                return (parts[0][0] + parts[parts.length - 1][0]).toUpperCase();
            } else if (parts.length === 1) {
                return parts[0].substring(0, 2).toUpperCase();
            }
            
            return 'U';
        }
        
        // Helper function to get user initials consistently (matching updatePostCreationUserDisplay logic)
        function getUserInitials(user) {
            if (!user) return 'U';
            
            // Priority order matching updatePostCreationUserDisplay:
            // 1. first_name + last_name (e.g., "HO" from "Hoa" + "Oar")
            // 2. username (using generateInitials for proper parsing)
            // 3. email (first 2 chars)
            // 4. default 'U'
            
            if (user.first_name && user.last_name) {
                return (user.first_name[0] + user.last_name[0]).toUpperCase();
            } else if (user.username) {
                return generateInitials(user.username);
            } else if (user.email) {
                return user.email.substring(0, 2).toUpperCase();
            }
            return 'U';
        }
        
        // Cache for user avatars to avoid repeated queries
        const userAvatarCache = {};
        
        // Fetch user avatar from user_profiles table
        async function fetchUserAvatar(authorId) {
            // Check cache first
            if (userAvatarCache[authorId] !== undefined) {
                return userAvatarCache[authorId];
            }
            
            try {
                const { data, error } = await window.dcfSupabase
                    .from('user_profiles')
                    .select('avatar_url')
                    .eq('id', authorId)
                    .single();
                
                if (error) {
                    console.error('Error fetching avatar for user:', authorId, error);
                    userAvatarCache[authorId] = null;
                    return null;
                }
                
                // Cache the result
                userAvatarCache[authorId] = data?.avatar_url || null;
                return userAvatarCache[authorId];
            } catch (error) {
                console.error('Error fetching avatar:', error);
                userAvatarCache[authorId] = null;
                return null;
            }
        }

        // Initialize page
        async function initializePage() {
            await loadEvent();
            
            // Initialize posts functionality
            initializePostCreation();
            loadPostsFeed();
            
            // Immediately update post creation display with whatever data is available
            updatePostCreationUserDisplay();
            
            // Set up retry mechanism for user display
            let retryCount = 0;
            const maxRetries = 10;
            const retryInterval = setInterval(() => {
                retryCount++;
                console.log(`Retry ${retryCount}: Checking for user data...`);
                
                const user = getCurrentUser() || window.dcfUser?.profile;
                if (user) {
                    console.log('✅ User data found, updating display');
                    updatePostCreationUserDisplay();
                    updateCommentFormAvatars();
                    clearInterval(retryInterval);
                } else if (retryCount >= maxRetries) {
                    console.log('❌ Max retries reached, user might not be logged in');
                    clearInterval(retryInterval);
                }
            }, 500); // Check every 500ms
        }
        
        // Re-check ownership after authentication completes
        function recheckOwnershipAfterAuth() {
            console.log('🔄 RE-CHECKING OWNERSHIP AFTER AUTH COMPLETION');
            
            if (!window.currentEvent) {
                console.log('No project loaded yet, waiting...');
                return;
            }
            
            const currentUser = window.getCurrentUser ? window.getCurrentUser() : null;
            
            if (!currentUser) {
                console.log('Still no user after auth - may not be logged in');
                return;
            }
            
            console.log('Re-check - Current User:', currentUser);
            console.log('Re-check - User ID:', currentUser.id);
            console.log('Re-check - Project Author ID:', window.currentEvent.author_id);
            
            // Check ownership
            const isOwnerById = currentUser.id === window.currentEvent.author_id;
            const isOwnerByEmail = window.currentEvent.author && 
                                  currentUser.email === window.currentEvent.author.email;
            
            const isOwner = isOwnerById || isOwnerByEmail;
            
            console.log('Re-check - Ownership by ID:', isOwnerById);
            console.log('Re-check - Ownership by email:', isOwnerByEmail);
            console.log('Re-check - FINAL RESULT:', isOwner);
            
            if (isOwner) {
                console.log('✅ OWNERSHIP CONFIRMED AFTER AUTH - SHOWING CONTROLS');
                
                // Show edit cover button
                const editCoverBtn = document.getElementById('editCoverBtn');
                if (editCoverBtn) {
                    editCoverBtn.style.display = 'flex';
                    console.log('✅ Edit cover button shown');
                }
                
                // Show owner controls (Manage Project button in hero)
                const ownerControls = document.getElementById('ownerControls');
                if (ownerControls) {
                    ownerControls.style.display = 'flex';
                    console.log('✅ Owner controls shown');
                }
                
                // Update stats section buttons
                const joinBtn = document.getElementById('joinEventBtn');
                const manageBtn = document.getElementById('manageProjectBtn');
                if (joinBtn) {
                    joinBtn.style.display = 'none';
                    console.log('✅ Join button hidden');
                }
                if (manageBtn) {
                    manageBtn.style.display = 'inline-flex';
                    console.log('✅ Manage button shown');
                }
                
                // Also re-run updateProjectButtons for completeness
                if (typeof updateProjectButtons === 'function') {
                    updateProjectButtons(window.currentEvent);
                }
            }
        }
        
        // Listen for auth completion and re-check ownership
        function setupAuthListener() {
            console.log('🎧 Setting up auth completion listener');
            
            // Method 1: Check every 500ms for auth to be ready
            const authCheckInterval = setInterval(() => {
                if (window.dcfUser && window.dcfUser.isLoggedIn) {
                    console.log('✅ Auth detected as complete, re-checking ownership');
                    clearInterval(authCheckInterval);
                    
                    // Give it a moment for all data to settle
                    setTimeout(() => {
                        recheckOwnershipAfterAuth();
                        // Also update post creation user display
                        console.log('🔄 Updating post creation display after auth');
                        updatePostCreationUserDisplay();
                    updateCommentFormAvatars();
                    }, 100);
                }
            }, 500);
            
            // Stop checking after 10 seconds
            setTimeout(() => {
                clearInterval(authCheckInterval);
            }, 10000);
            
            // Method 2: Also listen for Supabase auth state changes
            if (window.dcfSupabase) {
                window.dcfSupabase.auth.onAuthStateChange((event, session) => {
                    console.log('🔐 Auth state changed:', event);
                    if (event === 'SIGNED_IN' || event === 'TOKEN_REFRESHED' || event === 'USER_UPDATED') {
                        console.log('Auth event detected, waiting for dcfUser to update...');
                        setTimeout(() => {
                            recheckOwnershipAfterAuth();
                        }, 500);
                    }
                });
            }
        }
        
        // Like/Share Functionality using Universal Analytics System
        
        // Get project ID from URL or use default
        function getEventId() {
            const urlParams = new URLSearchParams(window.location.search);
            return urlParams.get('id') || 'ai-ethics-curriculum';
        }
        
        // Initialize project like status using Universal Analytics System
        async function initializeProjectLike() {
            const eventId = getEventId();
            
            try {
                // Check if user has liked this project
                const hasLiked = await window.hasUserInteracted('event', eventId, 'like');
                const likeCount = await window.getInteractionCount('event', eventId, 'like');
                
                // Update UI
                const likeBtn = document.getElementById('likeBtn');
                const likeText = document.getElementById('likeText');
                const likeCountEl = document.getElementById('likeCount');
                
                if (!likeBtn) return;
                
                if (hasLiked) {
                    likeBtn.classList.add('active');
                    likeText.textContent = 'Liked';
                    likeBtn.querySelector('span:first-child').textContent = '❤️';
                } else {
                    likeBtn.classList.remove('active');
                    likeText.textContent = 'Like';
                    likeBtn.querySelector('span:first-child').textContent = '🤍';
                }
                
                likeCountEl.textContent = `(${likeCount})`;
            } catch (err) {
                console.error('Error initializing like status:', err);
            }
        }
        
        // Toggle like using Universal Analytics System
        async function toggleLike() {
            const eventId = getEventId();
            const projectTitle = document.querySelector('.profile-name')?.textContent || 'Project';
            
            // Use Universal Analytics System toggle
            const result = await window.toggleInteraction('event', eventId, 'like', {
                buttonId: 'likeBtn',
                countElementId: 'likeCount',
                activeEmoji: '❤️',
                inactiveEmoji: '🤍',
                metadata: { title: projectTitle }
            });
            
            if (!result.success) {
                console.error('Failed to toggle like:', result.error);
            }
        }
        
        // Initialize like status when page loads (removed duplicate view tracking)
        document.addEventListener('DOMContentLoaded', async () => {
            const eventId = getEventId();
            
            // Initialize like status
            initializeProjectLike();
            
            // REMOVED duplicate view tracking from here
            // View tracking is already done in loadProject() function above
            // This prevents the view count from incrementing by 2
            
            // Update view count if element exists
            const viewCountEl = document.getElementById('viewCount');
            if (viewCountEl) {
                const viewCount = await window.getInteractionCount('event', eventId, 'view');
                viewCountEl.textContent = `${viewCount} views`;
            }
        });
        
        function toggleShareMenu() {
            const shareMenu = document.getElementById('shareMenu');
            shareMenu.classList.toggle('active');
            
            // Track share button click
            const eventId = getEventId();
            window.trackInteraction('event', eventId, 'share');
        }
        
        function copyLink() {
            const url = window.location.href;
            navigator.clipboard.writeText(url).then(() => {
                showAlert('Link copied to clipboard!', 'success');
                toggleShareMenu();
                // Track copy link interaction
                const eventId = getEventId();
                window.trackInteraction('event', eventId, 'share', { method: 'copy_link' });
            });
        }
        
        function shareEmail() {
            const project = window.currentEvent;
            const subject = encodeURIComponent(`Check out this project: ${project?.title || 'DCF Project'}`);
            const body = encodeURIComponent(`I thought you might be interested in this project:\n\n${project?.title || 'Project'}\n${project?.brief_description || project?.description || ''}\n\nView it here: ${window.location.href}`);
            window.open(`mailto:?subject=${subject}&body=${body}`);
            toggleShareMenu();
            // Track email share
            const eventId = getEventId();
            window.trackInteraction('event', eventId, 'share', { method: 'email' });
        }
        
        function shareTwitter() {
            const project = window.currentEvent;
            const text = encodeURIComponent(`Check out this amazing project: ${project?.title || 'DCF Project'}`);
            const url = encodeURIComponent(window.location.href);
            window.open(`https://twitter.com/intent/tweet?text=${text}&url=${url}`);
            toggleShareMenu();
            // Track Twitter share
            const eventId = getEventId();
            window.trackInteraction('event', eventId, 'share', { method: 'twitter' });
        }
        
        function shareLinkedIn() {
            const url = encodeURIComponent(window.location.href);
            window.open(`https://www.linkedin.com/sharing/share-offsite/?url=${url}`);
            toggleShareMenu();
            // Track LinkedIn share
            const eventId = getEventId();
            window.trackInteraction('event', eventId, 'share', { method: 'linkedin' });
        }
        
        // Close share menu when clicking outside
        document.addEventListener('click', function(e) {
            const shareDropdown = e.target.closest('.share-dropdown');
            if (!shareDropdown) {
                const shareMenu = document.getElementById('shareMenu');
                if (shareMenu) {
                    shareMenu.classList.remove('active');
                }
            }
        });

        // Function to set hero background image
        function setHeroBackground(imageUrl) {
            const heroBackground = document.getElementById('heroBackground');
            if (imageUrl) {
                heroBackground.style.backgroundImage = `url(${imageUrl})`;
            }
            // Apply saved position from database if available
            if (window.currentEvent && heroBackground) {
                if (window.currentEvent.cover_position) {
                    // Apply the position directly from database
                    heroBackground.style.backgroundPosition = window.currentEvent.cover_position;
                    
                    // Extract percentage for slider
                    const match = window.currentEvent.cover_position.match(/center\s+(\d+)%/);
                    if (match) {
                        currentCoverPosition = parseFloat(match[1]);
                    } else {
                        currentCoverPosition = 50;
                    }
                    console.log('Applied saved cover position from database:', window.currentEvent.cover_position);
                } else {
                    // Default to center
                    heroBackground.style.backgroundPosition = `center 50%`;
                    currentCoverPosition = 50;
                    console.log('Using default cover position');
                }
            }
        }

        // Function to set hero title and subtitle
        function setHeroTitle(title, subtitle) {
            const heroTitle = document.getElementById('heroTitle');
            const heroSubtitle = document.getElementById('heroSubtitle');
            
            heroTitle.textContent = title || 'Title Goes Here';
            heroSubtitle.textContent = subtitle || 'Event Date and Time Goes Here';
        }

        // Function to set about section content with word limit and website link
        function setAboutContent(title, description, expandedDescription, websiteUrl) {
            const aboutTitle = document.getElementById('aboutTitle');
            const aboutDescription = document.getElementById('aboutDescription');
            const websiteLink = document.getElementById('projectWebsiteLink');
            
            if (title) {
                aboutTitle.textContent = title;
            }
            
            // Handle website link
            if (websiteUrl && websiteLink) {
                websiteLink.href = websiteUrl;
                websiteLink.style.display = 'inline-block';
            } else if (websiteLink) {
                websiteLink.style.display = 'none';
            }
            
            if (description) {
                // Save the Like/Share buttons before modifying innerHTML
                const projectActions = aboutDescription.querySelector('.project-actions');
                
                // Use brief description as primary, full description for expansion
                const hasExpandedContent = expandedDescription && expandedDescription.trim() !== '';
                
                if (hasExpandedContent) {
                    // Show brief description with option to expand to full description
                    aboutDescription.innerHTML = `
                        <p>
                            <span id="truncatedDesc">${description}</span>
                            <span id="fullDesc" style="display: none;">${description}<br><br>${expandedDescription}</span>
                            <span class="description-more" id="moreLink" onclick="showFullDescription()"> read more</span>
                            <span class="description-more" id="lessLink" style="display: none;" onclick="showLessDescription()"> show less</span>
                        </p>
                    `;
                } else {
                    // Just show the brief description if no full description available
                    aboutDescription.innerHTML = `<p>${description}</p>`;
                }
                
                // Re-append the Like/Share buttons after updating the description
                if (projectActions) {
                    aboutDescription.appendChild(projectActions);
                }
            }
        }

        // Function to show full description
        function showFullDescription() {
            const truncatedDesc = document.getElementById('truncatedDesc');
            const fullDesc = document.getElementById('fullDesc');
            const moreLink = document.getElementById('moreLink');
            const lessLink = document.getElementById('lessLink');
            
            if (truncatedDesc && fullDesc && moreLink && lessLink) {
                truncatedDesc.style.display = 'none';
                fullDesc.style.display = 'inline';
                moreLink.style.display = 'none';
                lessLink.style.display = 'inline';
            }
        }
        
        // Function to show less description (collapse back)
        function showLessDescription() {
            const truncatedDesc = document.getElementById('truncatedDesc');
            const fullDesc = document.getElementById('fullDesc');
            const moreLink = document.getElementById('moreLink');
            const lessLink = document.getElementById('lessLink');
            
            if (truncatedDesc && fullDesc && moreLink && lessLink) {
                truncatedDesc.style.display = 'inline';
                fullDesc.style.display = 'none';
                moreLink.style.display = 'inline';
                lessLink.style.display = 'none';
            }
        }

        // Function to set author details (privacy-safe)
        function setAuthorDetails(username, title, email, avatarInitials, avatarUrl) {
            const authorName = document.getElementById('authorName');
            const authorTitle = document.getElementById('authorTitle');
            const authorEmail = document.getElementById('authorEmail');
            const authorAvatar = document.getElementById('authorAvatar');
            
            // Debug logging
            console.log('DEBUG setAuthorDetails - avatarUrl:', avatarUrl);
            console.log('DEBUG setAuthorDetails - avatarInitials:', avatarInitials);
            console.log('DEBUG setAuthorDetails - authorAvatar element:', authorAvatar);
            
            if (username && authorName) authorName.textContent = username;
            if (title && authorTitle) authorTitle.textContent = title;
            
            // NEVER show email address - hide the email element
            if (authorEmail) {
                authorEmail.style.display = 'none';
            }
            
            // Handle avatar - use profile pic if available, otherwise initials
            if (authorAvatar) {
                if (avatarUrl) {
                    console.log('DEBUG - Setting avatar background image:', avatarUrl);
                    authorAvatar.style.backgroundImage = `url(${avatarUrl})`;
                    authorAvatar.style.backgroundSize = 'cover';
                    authorAvatar.style.backgroundPosition = 'center';
                    authorAvatar.textContent = '';
                } else {
                    authorAvatar.style.backgroundImage = '';
                    authorAvatar.style.background = 'linear-gradient(135deg, #000, #333)';
                    authorAvatar.textContent = avatarInitials || 'U';
                }
            }
        }

        // Load real event statistics from database
        async function loadEventStatistics(eventId) {
            try {
                // Show loading state
                document.querySelectorAll('.stat-number').forEach(el => {
                    el.textContent = '...';
                });
                
                // Get registered attendees count
                let registeredCount = 0;
                let waitlistCount = 0;
                try {
                    const { count: registered, error: regError } = await window.dcfSupabase
                        .from('event_attendees')
                        .select('*', { count: 'exact', head: true })
                        .eq('event_id', eventId)
                        .eq('status', 'registered');
                    
                    const { count: waitlist, error: waitError } = await window.dcfSupabase
                        .from('event_attendees')
                        .select('*', { count: 'exact', head: true })
                        .eq('event_id', eventId)
                        .eq('status', 'waitlist');
                    
                    if (!regError && registered !== null) {
                        registeredCount = registered;
                    }
                    if (!waitError && waitlist !== null) {
                        waitlistCount = waitlist;
                    }
                } catch (error) {
                    console.log('event_attendees table not available:', error);
                    registeredCount = 0;
                    waitlistCount = 0;
                }
                
                // Get resources count
                let resourcesCount = 0;
                try {
                    const { count: resources, error: resError } = await window.dcfSupabase
                        .from('event_resources')
                        .select('*', { count: 'exact', head: true })
                        .eq('event_id', eventId);
                    
                    if (!resError && resources !== null) {
                        resourcesCount = resources;
                    }
                } catch (error) {
                    console.log('event_resources table not available:', error);
                    resourcesCount = 0;
                }
                
                // Get views count from universal_analytics
                let viewsCount = 0;
                try {
                    const { count: viewCount, error: viewError } = await window.dcfSupabase
                        .from('universal_analytics')
                        .select('*', { count: 'exact', head: true })
                        .eq('content_type', 'event')
                        .eq('content_id', eventId)
                        .eq('interaction_type', 'view');
                    
                    if (!viewError && viewCount !== null) {
                        viewsCount = viewCount;
                    }
                } catch (error) {
                    console.log('Error loading view count:', error);
                }
                
                // Get shares count from universal_analytics
                let sharesCount = 0;
                try {
                    const { count: shareCount, error: shareError } = await window.dcfSupabase
                        .from('universal_analytics')
                        .select('*', { count: 'exact', head: true })
                        .eq('content_type', 'event')
                        .eq('content_id', eventId)
                        .eq('interaction_type', 'share');
                    
                    if (!shareError && shareCount !== null) {
                        sharesCount = shareCount;
                    }
                } catch (error) {
                    console.log('Error loading share count:', error);
                }
                
                // Calculate spots left
                const maxAttendees = window.currentEvent?.max_attendees || 100;
                const spotsLeft = Math.max(0, maxAttendees - registeredCount);
                
                // Set the stats with real data
                console.log('Setting event statistics:', {
                    registered: registeredCount,
                    spotsLeft: spotsLeft,
                    waitlist: waitlistCount,
                    resources: resourcesCount,
                    views: viewsCount,
                    shares: sharesCount
                });
                
                setEventStatsData(registeredCount, spotsLeft, waitlistCount, resourcesCount, viewsCount, sharesCount);
                
            } catch (error) {
                console.error('Error loading event statistics:', error);
                // Fallback to minimal stats if there's an error
                setEventStatsData(0, 0, 0, 0, 0, 0);
            }
        }

        // Function to set event stats data
        function setEventStatsData(registered, spotsLeft, waitlist, resources, views, shares) {
            const statRegistered = document.getElementById('statRegistered');
            const statSpots = document.getElementById('statSpots');
            const statWaitlist = document.getElementById('statWaitlist');
            const statResources = document.getElementById('statResources');
            const statViews = document.getElementById('statViews');
            const statShares = document.getElementById('statShares');
            
            if (statRegistered) statRegistered.textContent = registered || 0;
            if (statSpots) statSpots.textContent = spotsLeft || 0;
            if (statWaitlist) statWaitlist.textContent = waitlist || 0;
            if (statResources) statResources.textContent = resources || 0;
            if (statViews) statViews.textContent = views || 0;
            if (statShares) statShares.textContent = shares || 0;
        }

        // Legacy function for compatibility
        function setStatsData(members, tasks, followers, files, views, shares) {
            console.log('=== setStatsData CALL DEBUG ===');
            console.log('Call stack:', new Error().stack);
            console.log('Parameters received:', {members, tasks, followers, files, views, shares});
            console.log('Parameter types:', {
                members: typeof members, 
                tasks: typeof tasks, 
                followers: typeof followers, 
                files: typeof files, 
                views: typeof views, 
                shares: typeof shares
            });
            
            // Force all parameters to be numbers or default values
            const safeMembers = (typeof members === 'number') ? members : 1;
            const safeTasks = (typeof tasks === 'number') ? tasks : 0;
            const safeFollowers = (typeof followers === 'number') ? followers : 0;
            const safeFiles = (typeof files === 'number') ? files : 0;
            const safeViews = (typeof views === 'number') ? views : 0;
            const safeShares = (typeof shares === 'number') ? shares : 0;
            
            console.log('Safe values:', {safeMembers, safeTasks, safeFollowers, safeFiles, safeViews, safeShares});
            
            const statMembers = document.getElementById('statMembers');
            const statTasks = document.getElementById('statTasks');
            const statFollowers = document.getElementById('statFollowers');
            const statFiles = document.getElementById('statFiles');
            const statViews = document.getElementById('statViews');
            const statShares = document.getElementById('statShares');
            
            if (statMembers) statMembers.textContent = safeMembers;
            if (statTasks) statTasks.textContent = safeTasks;
            if (statFollowers) statFollowers.textContent = safeFollowers;
            if (statFiles) statFiles.textContent = safeFiles;
            if (statViews) statViews.textContent = safeViews;
            if (statShares) statShares.textContent = safeShares;
            
            console.log('=== END setStatsData DEBUG ===');
        }

        // Check user permissions for the event
        async function checkUserPermissions(eventId, userId) {
            if (!eventId || !userId || !window.dcfSupabase) {
                return null;
            }
            
            try {
                // First check if user is a member of the project
                const { data: memberData, error: memberError } = await window.dcfSupabase
                    .from('project_members')
                    .select('role, permission_template_id, custom_permissions')
                    .eq('project_id', eventId)
                    .eq('user_id', userId)
                    .eq('status', 'active')
                    .maybeSingle();
                
                if (memberError || !memberData) {
                    console.log('User is not a member of this project');
                    return null;
                }
                
                // If user has custom permissions, use those
                if (memberData.custom_permissions) {
                    return {
                        role: memberData.role,
                        permissions: memberData.custom_permissions,
                        isMember: true
                    };
                }
                
                // Otherwise, fetch permission template if exists
                if (memberData.permission_template_id) {
                    const { data: templateData, error: templateError } = await window.dcfSupabase
                        .from('permission_templates')
                        .select('*')
                        .eq('id', memberData.permission_template_id)
                        .maybeSingle();
                    
                    if (!templateError && templateData) {
                        return {
                            role: memberData.role,
                            permissions: {
                                can_edit_project: templateData.can_edit_project || false,
                                can_manage_members: templateData.can_manage_members || false,
                                can_upload_files: templateData.can_upload_files || false,
                                can_create_posts: templateData.can_create_posts || false,
                                can_moderate_comments: templateData.can_moderate_comments || false,
                                can_manage_settings: templateData.can_manage_settings || false
                            },
                            isMember: true
                        };
                    }
                }
                
                // Default permissions based on role
                const defaultPermissions = getDefaultPermissionsByRole(memberData.role);
                return {
                    role: memberData.role,
                    permissions: defaultPermissions,
                    isMember: true
                };
                
            } catch (error) {
                console.error('Error checking user permissions:', error);
                return null;
            }
        }
        
        // Get default permissions based on role
        function getDefaultPermissionsByRole(role) {
            switch(role) {
                case 'owner':
                case 'admin':
                    return {
                        can_edit_project: true,
                        can_manage_members: true,
                        can_upload_files: true,
                        can_create_posts: true,
                        can_moderate_comments: true,
                        can_manage_settings: true
                    };
                case 'moderator':
                    return {
                        can_edit_project: false,
                        can_manage_members: false,
                        can_upload_files: true,
                        can_create_posts: true,
                        can_moderate_comments: true,
                        can_manage_settings: false
                    };
                case 'contributor':
                    return {
                        can_edit_project: false,
                        can_manage_members: false,
                        can_upload_files: true,
                        can_create_posts: true,
                        can_moderate_comments: false,
                        can_manage_settings: false
                    };
                case 'viewer':
                default:
                    return {
                        can_edit_project: false,
                        can_manage_members: false,
                        can_upload_files: false,
                        can_create_posts: false,
                        can_moderate_comments: false,
                        can_manage_settings: false
                    };
            }
        }
        
        // Check event join policy
        async function checkEventJoinPolicy(eventId) {
            if (!eventId || !window.dcfSupabase) {
                return 'open'; // Default to open if can't check
            }
            
            try {
                const { data: settingsData, error } = await window.dcfSupabase
                    .from('project_settings')
                    .select('join_policy')
                    .eq('project_id', eventId)
                    .maybeSingle();
                
                if (!error && settingsData && settingsData.join_policy) {
                    return settingsData.join_policy;
                }
                
                // Default to open if no settings found
                return 'open';
                
            } catch (error) {
                console.error('Error checking project join policy:', error);
                return 'open';
            }
        }
        
        // Update UI based on user permissions
        async function updateUIBasedOnPermissions(eventId) {
            const currentUser = window.getCurrentUser ? window.getCurrentUser() : null;
            if (!currentUser) {
                console.log('No user logged in, showing public view');
                return;
            }
            
            // Check user permissions
            const userPermissions = await checkUserPermissions(eventId, currentUser.id);
            
            // Store permissions globally for other functions to use
            window.currentUserProjectPermissions = userPermissions;
            
            if (userPermissions) {
                console.log('User permissions:', userPermissions);
                
                // Update manage/edit button visibility based on permissions
                const ownerControls = document.getElementById('ownerControls');
                const manageBtn = document.getElementById('manageProjectBtn');
                
                if (userPermissions.permissions.can_edit_project || userPermissions.permissions.can_manage_settings) {
                    if (ownerControls) ownerControls.style.display = 'flex';
                    if (manageBtn) manageBtn.style.display = 'inline-flex';
                    
                    // Also show edit cover button if they can edit
                    const editCoverBtn = document.getElementById('editCoverBtn');
                    if (editCoverBtn && userPermissions.permissions.can_edit_project) {
                        editCoverBtn.style.display = 'flex';
                    }
                } else {
                    if (ownerControls) ownerControls.style.display = 'none';
                    if (manageBtn) manageBtn.style.display = 'none';
                }
                
                // Update join button to show member status
                const joinBtn = document.getElementById('joinEventBtn');
                const joinCardTitle = document.getElementById('joinCardTitle');
                const joinCardDescription = document.getElementById('joinCardDescription');
                
                if (joinBtn) {
                    joinBtn.style.display = 'none'; // Hide join button for members
                }
                
                if (joinCardTitle) {
                    joinCardTitle.textContent = `You're a ${userPermissions.role}`;
                }
                
                if (joinCardDescription) {
                    const permCount = Object.values(userPermissions.permissions).filter(p => p === true).length;
                    joinCardDescription.textContent = `You have ${permCount} active permissions in this project`;
                }
                
                // Control file upload sections visibility
                const fileUploadElements = document.querySelectorAll('[data-requires-upload-permission]');
                fileUploadElements.forEach(element => {
                    const originalDisplay = element.style.display || 'block';
                    element.style.display = userPermissions.permissions.can_upload_files ? originalDisplay : 'none';
                });
                
                // Control post/comment form visibility
                const postFormElements = document.querySelectorAll('[data-requires-post-permission]');
                postFormElements.forEach(element => {
                    const originalDisplay = window.getComputedStyle(element).display;
                    element.style.display = userPermissions.permissions.can_create_posts ? 
                        (originalDisplay === 'none' ? 'block' : originalDisplay) : 'none';
                });
                
            } else {
                // User is not a member - check join policy and update button accordingly
                const joinPolicy = await checkEventJoinPolicy(eventId);
                const joinBtn = document.getElementById('joinEventBtn');
                const joinCardTitle = document.getElementById('joinCardTitle');
                const joinCardDescription = document.getElementById('joinCardDescription');
                
                if (joinBtn) {
                    if (joinPolicy === 'application') {
                        joinBtn.innerHTML = '📝 Apply to Join';
                        joinBtn.onclick = () => applyToJoinEvent(eventId);
                    } else {
                        joinBtn.innerHTML = '🤝 Join Project';
                        joinBtn.onclick = () => joinEvent(eventId);
                    }
                    joinBtn.style.display = 'inline-flex';
                }
                
                if (joinCardTitle) {
                    joinCardTitle.textContent = joinPolicy === 'application' ? 
                        'Apply to Join This Project' : 
                        'Join This Project';
                }
                
                if (joinCardDescription) {
                    joinCardDescription.textContent = joinPolicy === 'application' ?
                        'Submit an application to become a project member' :
                        'Become a member to contribute and participate';
                }
                
                // Hide manage buttons for non-members
                const ownerControls = document.getElementById('ownerControls');
                const manageBtn = document.getElementById('manageProjectBtn');
                if (ownerControls) ownerControls.style.display = 'none';
                if (manageBtn) manageBtn.style.display = 'none';
            }
        }
        
        // Join project directly (for open projects)
        async function joinEvent(eventId) {
            const currentUser = window.getCurrentUser ? window.getCurrentUser() : null;
            if (!currentUser) {
                showNotification('Please log in to join projects', 'warning');
                return;
            }
            
            try {
                const { data, error } = await window.dcfSupabase
                    .from('project_members')
                    .insert({
                        project_id: projectId,
                        user_id: currentUser.id,
                        role: 'viewer',
                        status: 'active',
                        joined_at: new Date().toISOString()
                    });
                
                if (error) throw error;
                
                showNotification('Successfully joined the project!', 'success');
                
                // Refresh the page to update permissions
                await updateUIBasedOnPermissions(projectId);
                await loadEventStatistics(projectId);
                
            } catch (error) {
                console.error('Error joining project:', error);
                showNotification('Failed to join project', 'error');
            }
        }
        
        // Apply to join project (for application-only projects)
        async function applyToJoinEvent(eventId) {
            const currentUser = window.getCurrentUser ? window.getCurrentUser() : null;
            if (!currentUser) {
                showNotification('Please log in to apply to projects', 'warning');
                return;
            }
            
            // For now, just show a message - full implementation would create an application record
            showNotification('Application feature coming soon! Contact the project owner for now.', 'info');
        }

        // Function to set join card content
        function setJoinCardContent(title, description, buttonText = '🤝 Join Now') {
            const joinCardTitle = document.getElementById('joinCardTitle');
            const joinCardDescription = document.getElementById('joinCardDescription');
            const joinEventBtn = document.getElementById('joinEventBtn');
            
            if (title && joinCardTitle) joinCardTitle.textContent = title;
            if (description && joinCardDescription) joinCardDescription.textContent = description;
            if (buttonText && joinEventBtn) joinEventBtn.innerHTML = buttonText;
        }

        // Handle event registration
        async function handleJoinEvent() {
            const eventId = getEventIdFromURL();
            const joinBtn = document.getElementById('joinEventBtn');
            const currentUser = window.getCurrentUser ? window.getCurrentUser() : null;
            
            if (!currentUser || !currentUser.email) {
                showNotification('Please log in to register for events', 'warning');
                return;
            }
            
            // Check if already registered
            try {
                const { data: existing, error: checkError } = await window.dcfSupabase
                    .from('event_attendees')
                    .select('id, status')
                    .eq('event_id', eventId)
                    .eq('user_id', currentUser.id)
                    .maybeSingle();
                
                if (existing) {
                    if (existing.status === 'registered') {
                        showNotification('You are already registered for this event', 'info');
                    } else if (existing.status === 'waitlist') {
                        showNotification('You are on the waitlist for this event', 'info');
                    }
                    return;
                }
                
                // Check event capacity
                const { count: registeredCount } = await window.dcfSupabase
                    .from('event_attendees')
                    .select('*', { count: 'exact', head: true })
                    .eq('event_id', eventId)
                    .eq('status', 'registered');
                
                const maxAttendees = window.currentEvent?.max_attendees || 100;
                const status = registeredCount >= maxAttendees ? 'waitlist' : 'registered';
                
                // Register for event
                const { data, error } = await window.dcfSupabase
                    .from('event_attendees')
                    .insert({
                        event_id: eventId,
                        user_id: currentUser.id,
                        status: status,
                        registered_at: new Date().toISOString()
                    });
                
                if (error) throw error;
                
                if (status === 'registered') {
                    showNotification('Successfully registered for the event!', 'success');
                    joinBtn.innerHTML = '✓ Registered';
                    joinBtn.disabled = true;
                } else {
                    showNotification('Added to waitlist - we\'ll notify you if a spot opens up', 'info');
                    joinBtn.innerHTML = '⏳ On Waitlist';
                    joinBtn.disabled = true;
                }
                
                // Reload statistics
                await loadEventStatistics(eventId);
                
            } catch (error) {
                console.error('Registration error:', error);
                showNotification('Failed to register for event', 'error');
            }
            
            if (!projectId || !window.currentEvent) {
                showNotification('Project information not loaded', 'error');
                return;
            }
            
            if (!joinBtn) return;
            
            // Check current follow status
            const isFollowing = joinBtn.textContent.includes('Following');
            
            try {
                if (isFollowing) {
                    // Unfollow the project
                    const { error } = await window.dcfSupabase
                        .from('project_follows')
                        .delete()
                        .eq('user_email', currentUser.email)
                        .eq('project_id', eventId);
                    
                    if (error) throw error;
                    
                    // Update button state
                    joinBtn.innerHTML = '➕ Follow Project';
                    joinBtn.classList.remove('following');
                    showNotification('Unfollowed project successfully', 'success');
                    
                    // Refresh statistics after unfollow
                    await loadEventStatistics(projectId);
                    
                } else {
                    // Follow the project
                    const { error } = await window.dcfSupabase
                        .from('project_follows')
                        .insert({
                            user_email: currentUser.email,
                            user_name: currentUser.name || currentUser.email.split('@')[0],
                            project_id: projectId,
                            project_name: window.currentEvent.title
                        });
                    
                    if (error) throw error;
                    
                    // Update button state
                    joinBtn.innerHTML = '✓ Following';
                    joinBtn.classList.add('following');
                    showNotification('Following project successfully', 'success');
                    
                    // Refresh statistics after follow
                    await loadEventStatistics(projectId);
                }
                
            } catch (error) {
                console.error('Error updating follow status:', error);
                showNotification('Failed to update follow status: ' + error.message, 'error');
            }
        }
        
        // Check registration status on page load
        async function checkFollowStatus() {
            const currentUser = window.getCurrentUser ? window.getCurrentUser() : null;
            if (!currentUser || !currentUser.email) return;
            
            const eventId = getEventIdFromURL();
            if (!eventId) return;
            
            try {
                const { data, error } = await window.dcfSupabase
                    .from('event_attendees')
                    .select('id, status')
                    .eq('event_id', eventId)
                    .eq('user_id', currentUser.id)
                    .maybeSingle();
                
                const joinBtn = document.getElementById('joinEventBtn');
                if (joinBtn) {
                    if (data) {
                        if (data.status === 'registered') {
                            joinBtn.innerHTML = '✓ Registered';
                            joinBtn.disabled = true;
                            joinBtn.classList.add('following');
                        } else if (data.status === 'waitlist') {
                            joinBtn.innerHTML = '⏳ On Waitlist';
                            joinBtn.disabled = true;
                            joinBtn.classList.add('following');
                        } else if (data.status === 'pending') {
                            joinBtn.innerHTML = '⏱️ Pending Approval';
                            joinBtn.disabled = true;
                        }
                    } else {
                        joinBtn.innerHTML = '📝 Register Now';
                        joinBtn.disabled = false;
                        joinBtn.classList.remove('following');
                    }
                }
            } catch (error) {
                // No registration found is expected, not an error
                const joinBtn = document.getElementById('joinEventBtn');
                if (joinBtn) {
                    joinBtn.innerHTML = '📝 Register Now';
                    joinBtn.disabled = false;
                    joinBtn.classList.remove('following');
                }
            }
        }

        // Function to set join card content
        function setJoinCardContent(title, description, buttonText = '🤝 Join Now') {
            const joinCardTitle = document.getElementById('joinCardTitle');
            const joinCardDescription = document.getElementById('joinCardDescription');
            const joinEventBtn = document.getElementById('joinEventBtn');
            
            if (title && joinCardTitle) joinCardTitle.textContent = title;
            if (description && joinCardDescription) joinCardDescription.textContent = description;
            if (buttonText && joinEventBtn) joinEventBtn.innerHTML = buttonText;
        }

        // Example usage:
        // setHeroBackground('your-image-url.jpg');
        // setHeroTitle('Your Custom Title', 'Your Project Goal');
        // setAboutContent('About Our Mission', 'This project aims to make a difference...');
        // setStatsData(15, 8, 23, 5, 'Project Impact');
        // setJoinCardContent('Join Our Mission', 'Be part of something bigger than yourself');

        // Cover Edit Modal Functions
        let selectedCoverFile = null;
        
        function openCoverEditModal() {
            console.log('🎨 Opening cover edit modal');
            const modal = document.getElementById('coverEditModal');
            
            if (modal) {
                console.log('✅ Modal element found');
                modal.classList.add('active');
                modal.style.display = 'flex'; // Also force display flex
                console.log('Modal classes:', modal.classList.toString());
            } else {
                console.error('❌ Cover edit modal element not found');
            }
        }
        
        function closeCoverEditModal() {
            console.log('🔒 Closing cover edit modal');
            const modal = document.getElementById('coverEditModal');
            const preview = document.getElementById('coverImagePreview');
            const placeholder = document.querySelector('.upload-placeholder');
            const saveBtn = document.getElementById('saveCoverBtn');
            const fileInput = document.getElementById('coverImageInput');
            
            if (modal) {
                modal.classList.remove('active');
                modal.style.display = 'none'; // Force hide
            }
            
            // Reset modal state
            if (preview) {
                preview.style.display = 'none';
                preview.src = '';
            }
            if (placeholder) {
                placeholder.style.display = 'block';
            }
            if (saveBtn) {
                saveBtn.disabled = true;
            }
            if (fileInput) {
                fileInput.value = ''; // Clear file input
            }
            selectedCoverFile = null;
        }
        
        function previewCoverImage(event) {
            console.log('📸 Preview cover image called');
            const file = event.target.files[0];
            
            if (!file) {
                console.log('No file selected');
                return;
            }
            
            console.log('File selected:', file.name, 'Type:', file.type, 'Size:', file.size);
            
            // Check file size (max 5MB)
            if (file.size > 5 * 1024 * 1024) {
                showAlert('File size must be less than 5MB', 'warning');
                event.target.value = ''; // Clear the input
                return;
            }
            
            // Check file type
            if (!file.type.startsWith('image/')) {
                showAlert('Please select an image file (JPG, PNG, GIF, etc.)', 'warning');
                event.target.value = ''; // Clear the input
                return;
            }
            
            selectedCoverFile = file;
            console.log('File accepted, showing preview');
            
            // Preview the image
            const reader = new FileReader();
            reader.onload = function(e) {
                const preview = document.getElementById('coverImagePreview');
                const placeholder = document.querySelector('.upload-placeholder');
                const saveBtn = document.getElementById('saveCoverBtn');
                
                if (preview) {
                    preview.src = e.target.result;
                    preview.style.display = 'block';
                    console.log('✅ Preview image displayed');
                }
                if (placeholder) {
                    placeholder.style.display = 'none';
                }
                if (saveBtn) {
                    saveBtn.disabled = false;
                    console.log('✅ Save button enabled');
                }
            };
            reader.onerror = function(error) {
                console.error('Error reading file:', error);
                showAlert('Error reading file. Please try again.', 'error');
            };
            reader.readAsDataURL(file);
        }
        
        async function saveCoverImage() {
            console.log('💾 Saving cover image');
            
            if (!selectedCoverFile) {
                showAlert('Please select an image first', 'warning');
                return;
            }
            
            if (!window.currentEvent) {
                showAlert('Project data not loaded. Please refresh the page.', 'error');
                return;
            }
            
            if (!window.dcfSupabase) {
                showAlert('Authentication system not ready. Please try again.', 'error');
                return;
            }
            
            const saveBtn = document.getElementById('saveCoverBtn');
            if (saveBtn) {
                saveBtn.disabled = true;
                saveBtn.textContent = 'Uploading...';
            }
            
            try {
                console.log('Uploading file:', selectedCoverFile.name);
                console.log('Project ID:', window.currentEvent.id);
                
                // Generate unique filename following the avatar pattern
                const timestamp = Date.now();
                const fileExt = selectedCoverFile.name.split('.').pop().toLowerCase();
                const fileName = `project_cover_${window.currentEvent.id}_${timestamp}.${fileExt}`;
                
                console.log('Generated filename:', fileName);
                
                // Try uploading to media bucket first
                let uploadData = null;
                let publicUrl = null;
                let uploadBucket = 'media';
                
                try {
                    const { data, error } = await window.dcfSupabase.storage
                        .from(uploadBucket)
                        .upload(fileName, selectedCoverFile, {
                            cacheControl: '3600',
                            upsert: true
                        });
                    
                    if (error) throw error;
                    uploadData = data;
                    
                } catch (uploadError) {
                    console.error('Upload error:', uploadError);
                    
                    // Try alternative buckets if media bucket fails
                    const alternativeBuckets = ['public', 'avatars', 'project-images', 'projects'];
                    let uploadSuccessful = false;
                    
                    for (const bucketName of alternativeBuckets) {
                        console.log(`Trying alternative bucket: ${bucketName}`);
                        try {
                            const { data, error } = await window.dcfSupabase.storage
                                .from(bucketName)
                                .upload(fileName, selectedCoverFile, {
                                    cacheControl: '3600',
                                    upsert: true
                                });
                                
                            if (!error) {
                                console.log(`✅ Upload successful to bucket: ${bucketName}`);
                                uploadData = data;
                                uploadBucket = bucketName;
                                uploadSuccessful = true;
                                break;
                            }
                        } catch (e) {
                            console.log(`Bucket ${bucketName} failed:`, e.message);
                        }
                    }
                    
                    if (!uploadSuccessful) {
                        showAlert('Could not upload to any storage bucket. Please ensure Supabase storage is configured.', 'error');
                        throw new Error('Upload failed to all available buckets');
                    }
                }
                
                console.log('Upload successful to bucket:', uploadBucket);
                console.log('Upload data:', uploadData);
                
                // Get public URL from the successful bucket
                const { data: urlData } = window.dcfSupabase.storage
                    .from(uploadBucket)
                    .getPublicUrl(fileName);
                
                publicUrl = urlData.publicUrl;
                console.log('Public URL:', publicUrl);
                
                // Update the projects table with new main_photo_url and timestamp
                const { data: updateData, error: updateError } = await window.dcfSupabase
                    .from('projects')
                    .update({ 
                        main_photo_url: publicUrl,
                        updated_at: new Date().toISOString()
                    })
                    .eq('id', window.currentEvent.id)
                    .select();
                
                if (updateError) {
                    console.error('Database update error:', updateError);
                    // Try to delete the uploaded file if database update fails
                    try {
                        await window.dcfSupabase.storage
                            .from(uploadBucket) // Use the bucket that was successful
                            .remove([fileName]);
                        console.log('Cleaned up uploaded file after database error');
                    } catch (cleanupError) {
                        console.error('Could not clean up file:', cleanupError);
                    }
                    throw new Error('Failed to update database: ' + updateError.message);
                }
                
                console.log('✅ Database updated successfully:', updateData);
                
                // Update the display immediately
                const heroBackground = document.getElementById('heroBackground');
                if (heroBackground) {
                    heroBackground.style.backgroundImage = `url(${publicUrl})`;
                    console.log('✅ Cover image updated on page');
                }
                window.currentEvent.main_photo_url = publicUrl;
                closeCoverEditModal();
                
                // Show success message and activate repositioning mode
                showAlert('Cover photo updated successfully! You can now adjust the vertical position.', 'success');
                enterRepositionMode();
                
            } catch (error) {
                console.error('Error uploading cover:', error);
                
                let errorMessage = 'Failed to upload cover photo: ';
                
                if (error.message) {
                    errorMessage += error.message;
                } else if (typeof error === 'string') {
                    errorMessage += error;
                } else {
                    errorMessage += 'Unknown error occurred';
                }
                
                showAlert(errorMessage, 'error');
            } finally {
                if (saveBtn) {
                    saveBtn.disabled = false;
                    saveBtn.textContent = 'Save Cover Photo';
                }
            }
        }
        
        // Comprehensive Authorization Audit Function
        async function runAuthorizationAudit() {
            console.log('');
            console.log('🔍 ============================================');
            console.log('🔍 COMPREHENSIVE AUTHORIZATION AUDIT STARTING');
            console.log('🔍 ============================================');
            console.log('');
            
            // 1. Check localStorage and sessionStorage
            console.log('📦 1. STORAGE AUDIT:');
            console.log('localStorage items:', Object.keys(localStorage));
            console.log('sessionStorage items:', Object.keys(sessionStorage));
            
            // Check for Supabase auth data
            const authKeys = Object.keys(localStorage).filter(key => key.includes('supabase') || key.includes('auth'));
            console.log('Auth-related localStorage keys:', authKeys);
            authKeys.forEach(key => {
                try {
                    const value = localStorage.getItem(key);
                    console.log(`  ${key}:`, value ? JSON.parse(value) : 'null');
                } catch (e) {
                    console.log(`  ${key}: [non-JSON value]`);
                }
            });
            
            // 2. Check global auth objects
            console.log('');
            console.log('🌍 2. GLOBAL OBJECTS AUDIT:');
            console.log('window.dcfUser:', window.dcfUser);
            console.log('window.dcfSupabase:', window.dcfSupabase ? 'Available' : 'Not available');
            console.log('window.getCurrentUser:', typeof window.getCurrentUser);
            
            // 3. Get current user via different methods
            console.log('');
            console.log('👤 3. CURRENT USER RETRIEVAL:');
            
            // Method 1: Via getCurrentUser function
            const userMethod1 = window.getCurrentUser ? window.getCurrentUser() : null;
            console.log('Method 1 - getCurrentUser():', userMethod1);
            
            // Method 2: Direct from dcfUser
            const userMethod2 = window.dcfUser?.profile;
            console.log('Method 2 - window.dcfUser.profile:', userMethod2);
            
            // Method 3: From Supabase directly
            if (window.dcfSupabase) {
                try {
                    const { data: { session } } = await window.dcfSupabase.auth.getSession();
                    console.log('Method 3 - Supabase session:', session);
                    if (session) {
                        console.log('  Session user ID:', session.user.id);
                        console.log('  Session user email:', session.user.email);
                        console.log('  Session user ID type:', typeof session.user.id);
                    }
                } catch (e) {
                    console.log('Method 3 - Error getting Supabase session:', e);
                }
            }
            
            // 4. Get project data
            console.log('');
            console.log('📋 4. PROJECT DATA AUDIT:');
            const eventId = getEventIdFromUrl();
            console.log('Project ID from URL:', projectId);
            
            if (window.currentEvent) {
                console.log('Current Project:', window.currentEvent);
                console.log('  Project author_id:', window.currentEvent.author_id);
                console.log('  Project author_id type:', typeof window.currentEvent.author_id);
                console.log('  Project author object:', window.currentEvent.author);
                if (window.currentEvent.author) {
                    console.log('    Author ID:', window.currentEvent.author.id);
                    console.log('    Author email:', window.currentEvent.author.email);
                    console.log('    Author username:', window.currentEvent.author.username);
                }
            } else {
                console.log('No current project loaded yet');
            }
            
            // 5. Comparison Analysis
            console.log('');
            console.log('🔄 5. COMPARISON ANALYSIS:');
            
            if (userMethod1 && window.currentEvent) {
                console.log('User ID:', userMethod1.id);
                console.log('Project author_id:', window.currentEvent.author_id);
                console.log('Are they equal (===)?', userMethod1.id === window.currentEvent.author_id);
                console.log('Are they equal (==)?', userMethod1.id == window.currentEvent.author_id);
                console.log('String comparison:', String(userMethod1.id) === String(window.currentEvent.author_id));
                
                if (window.currentEvent.author) {
                    console.log('');
                    console.log('Email comparison:');
                    console.log('  User email:', userMethod1.email);
                    console.log('  Author email:', window.currentEvent.author.email);
                    console.log('  Emails match?', userMethod1.email === window.currentEvent.author.email);
                    console.log('  Case-insensitive match?', 
                        userMethod1.email?.toLowerCase() === window.currentEvent.author.email?.toLowerCase());
                }
            }
            
            // 6. Check auth state
            console.log('');
            console.log('🔐 6. AUTHENTICATION STATE:');
            console.log('Is logged in (dcfUser)?', window.dcfUser?.isLoggedIn);
            console.log('Has profile?', !!window.dcfUser?.profile);
            console.log('Has session?', !!window.dcfUser?.session);
            
            // 7. Function availability
            console.log('');
            console.log('⚙️ 7. FUNCTION AVAILABILITY:');
            console.log('displayProject:', typeof displayProject);
            console.log('updateProjectButtons:', typeof updateProjectButtons);
            console.log('getCurrentUser:', typeof window.getCurrentUser);
            console.log('initializePage:', typeof initializePage);
            
            console.log('');
            console.log('🔍 ============================================');
            console.log('🔍 AUDIT COMPLETE - Check results above');
            console.log('🔍 ============================================');
            console.log('');
        }
        
        // Manual owner control functions for testing
        function forceShowOwnerControls() {
            console.log('🔧 FORCE SHOWING OWNER CONTROLS');
            
            const editCoverBtn = document.getElementById('editCoverBtn');
            const ownerControls = document.getElementById('ownerControls');
            const manageBtn = document.getElementById('manageProjectBtn');
            const joinBtn = document.getElementById('joinEventBtn');
            
            if (editCoverBtn) {
                editCoverBtn.style.display = 'flex';
                console.log('✅ Edit cover button shown');
            }
            
            if (ownerControls) {
                ownerControls.style.display = 'flex';
                console.log('✅ Owner controls shown');
            }
            
            if (manageBtn) {
                manageBtn.style.display = 'inline-flex';
                console.log('✅ Manage button shown');
            }
            
            if (joinBtn) {
                joinBtn.style.display = 'none';
                console.log('✅ Join button hidden');
            }
            
            console.log('Owner controls forcefully shown - use this to test functionality');
        }
        
        // Try alternative auth comparison
        async function tryAlternativeAuth() {
            console.log('🔄 TRYING ALTERNATIVE AUTH APPROACH');
            
            // Get fresh session from Supabase
            if (!window.dcfSupabase) {
                console.error('No Supabase client');
                return;
            }
            
            const { data: { session } } = await window.dcfSupabase.auth.getSession();
            
            if (!session) {
                console.log('No session found');
                return;
            }
            
            const currentUserId = session.user.id;
            const currentUserEmail = session.user.email;
            
            console.log('Current user ID from session:', currentUserId);
            console.log('Current user email from session:', currentUserEmail);
            
            if (window.currentEvent) {
                const projectAuthorId = window.currentEvent.author_id;
                const projectAuthorEmail = window.currentEvent.author?.email;
                
                console.log('Project author ID:', projectAuthorId);
                console.log('Project author email:', projectAuthorEmail);
                
                // Try different comparison methods
                console.log('');
                console.log('COMPARISON RESULTS:');
                console.log('ID match (strict):', currentUserId === projectAuthorId);
                console.log('ID match (loose):', currentUserId == projectAuthorId);
                console.log('Email match:', currentUserEmail === projectAuthorEmail);
                console.log('Email match (case-insensitive):', 
                    currentUserEmail?.toLowerCase() === projectAuthorEmail?.toLowerCase());
                
                // If any match, show controls
                if (currentUserId === projectAuthorId || 
                    currentUserId == projectAuthorId ||
                    currentUserEmail === projectAuthorEmail ||
                    currentUserEmail?.toLowerCase() === projectAuthorEmail?.toLowerCase()) {
                    
                    console.log('✅ MATCH FOUND - Showing owner controls');
                    forceShowOwnerControls();
                } else {
                    console.log('❌ No match found');
                    
                    // Log the actual values for debugging
                    console.log('');
                    console.log('DEBUG VALUES:');
                    console.log('User ID characters:', Array.from(String(currentUserId)));
                    console.log('Author ID characters:', Array.from(String(projectAuthorId)));
                }
            }
        }
        
        // Debug Edit Cover button
        function debugEditCoverButton() {
            console.log('🔍 DEBUGGING EDIT COVER BUTTON');
            
            const btn = document.getElementById('editCoverBtn');
            if (!btn) {
                console.error('Button not found in DOM');
                return;
            }
            
            console.log('Button found:', btn);
            console.log('Display:', btn.style.display);
            console.log('Visibility:', btn.style.visibility);
            console.log('Opacity:', btn.style.opacity);
            console.log('Disabled:', btn.disabled);
            console.log('Pointer events:', window.getComputedStyle(btn).pointerEvents);
            console.log('Z-index:', window.getComputedStyle(btn).zIndex);
            console.log('Position:', window.getComputedStyle(btn).position);
            console.log('Current onclick:', btn.onclick);
            
            // Force show the button
            btn.style.display = 'flex';
            btn.style.visibility = 'visible';
            btn.style.opacity = '1';
            btn.disabled = false;
            btn.style.pointerEvents = 'auto';
            btn.style.zIndex = '9999';
            
            // Add a simple click handler
            btn.onclick = function() {
                showAlert('BUTTON CLICKED - IT WORKS!', 'info');
                console.log('Button was clicked successfully!');
                
                // Try to open the modal
                const modal = document.getElementById('coverEditModal');
                if (modal) {
                    modal.style.display = 'flex';
                    modal.classList.add('active');
                    console.log('Modal should be visible now');
                } else {
                    console.error('Modal not found');
                }
            };
            
            console.log('✅ Button is now visible and clickable');
            console.log('Try clicking it now!');
        }
        
        // Make functions globally available for console testing
        window.forceShowOwnerControls = forceShowOwnerControls;
        window.runAuthorizationAudit = runAuthorizationAudit;
        window.tryAlternativeAuth = tryAlternativeAuth;
        window.recheckOwnershipAfterAuth = recheckOwnershipAfterAuth;
        window.openCoverEditModal = openCoverEditModal;
        window.closeCoverEditModal = closeCoverEditModal;
        window.previewCoverImage = previewCoverImage;
        window.saveCoverImage = saveCoverImage;
        window.debugEditCoverButton = debugEditCoverButton;
        
        // Initialize page when DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            console.log('📄 DOM Content Loaded - Starting initialization');
            
            // Load the project first
            initializePage();
            
            // Set up auth listener to re-check ownership when auth completes
            setupAuthListener();
            
            // Also set up periodic check for auth changes (for post box)
            let lastAuthState = false;
            setInterval(() => {
                const currentAuthState = window.dcfUser && window.dcfUser.isLoggedIn;
                if (currentAuthState !== lastAuthState) {
                    lastAuthState = currentAuthState;
                    console.log('🔄 Auth state changed:', currentAuthState);
                    updatePostCreationUserDisplay();
                    updateCommentFormAvatars();
                }
            }, 1000);
            
            // Setup Edit Cover button click handler
            function setupEditCoverButton() {
                const editCoverBtn = document.getElementById('editCoverBtn');
                if (!editCoverBtn) {
                    console.error('❌ Edit Cover button not found');
                    return;
                }
                
                console.log('🎯 Setting up Edit Cover button');
                
                // Clear any existing handlers
                editCoverBtn.onclick = null;
                const newBtn = editCoverBtn.cloneNode(true);
                editCoverBtn.parentNode.replaceChild(newBtn, editCoverBtn);
                
                // Get the fresh button reference
                const btn = document.getElementById('editCoverBtn');
                
                // Add click handler
                btn.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    console.log('🔴 EDIT COVER BUTTON CLICKED!');
                    
                    // Show modal
                    const modal = document.getElementById('coverEditModal');
                    if (modal) {
                        console.log('Opening cover edit modal');
                        modal.style.display = 'flex';
                        modal.classList.add('active');
                    } else {
                        console.error('Cover edit modal not found');
                        showAlert('Cover edit modal not found. Please refresh the page.', 'error');
                    }
                });
                
                console.log('✅ Edit Cover button handler attached');
            }
            
            // Call setup immediately and after delay
            setupEditCoverButton();
            setTimeout(setupEditCoverButton, 1000);
            setTimeout(setupEditCoverButton, 2000);
            
            // Run audit after a short delay to ensure everything is loaded
            setTimeout(() => {
                runAuthorizationAudit();
                
                // Also try alternative auth after audit
                setTimeout(() => {
                    tryAlternativeAuth();
                }, 500);
            }, 2000);
        });
        console.log('JavaScript parsing complete');
        // Cover Photo Repositioning Functions
        let currentCoverPosition = 50; // Default center position
        let originalPosition = 50;
        let isDragging = false;
        let dragStartY = 0;
        let dragStartPosition = 50;
        
        function startRepositionMode() {
            // Close the modal first
            closeCoverEditModal();
            // Then enter reposition mode
            enterRepositionMode();
        }
        
        function enterRepositionMode() {
            console.log('Entering reposition mode');
            const controls = document.getElementById('coverPositionControls');
            const heroBackground = document.getElementById('heroBackground');
            
            if (controls && heroBackground) {
                // Show controls
                controls.style.display = 'block';
                
                // Add repositioning class for cursor
                heroBackground.classList.add('repositioning');
                
                // Get current position if saved
                const currentBgPosition = heroBackground.style.backgroundPosition;
                if (currentBgPosition && currentBgPosition.includes('%')) {
                    const match = currentBgPosition.match(/(\d+(?:\.\d+)?)%/);
                    if (match) {
                        currentCoverPosition = parseFloat(match[1]);
                        originalPosition = currentCoverPosition;
                    }
                } else if (window.currentEvent.cover_position) {
                    // Try to extract from database value
                    const match = window.currentEvent.cover_position.match(/center\s+(\d+(?:\.\d+)?)%/);
                    if (match) {
                        currentCoverPosition = parseFloat(match[1]);
                        originalPosition = currentCoverPosition;
                    }
                }
                
                // Set slider value
                const slider = document.getElementById('positionSlider');
                if (slider) {
                    slider.value = currentCoverPosition;
                }
                
                // Enable drag functionality
                enableDragToReposition();
            }
        }
        
        function enableDragToReposition() {
            const heroBackground = document.getElementById('heroBackground');
            
            if (!heroBackground) return;
            
            heroBackground.addEventListener('mousedown', startDrag);
            document.addEventListener('mousemove', handleDrag);
            document.addEventListener('mouseup', stopDrag);
        }
        
        function disableDragToReposition() {
            const heroBackground = document.getElementById('heroBackground');
            
            if (!heroBackground) return;
            
            heroBackground.removeEventListener('mousedown', startDrag);
            document.removeEventListener('mousemove', handleDrag);
            document.removeEventListener('mouseup', stopDrag);
        }
        
        function startDrag(e) {
            const heroBackground = document.getElementById('heroBackground');
            if (!heroBackground || !heroBackground.classList.contains('repositioning')) return;
            
            isDragging = true;
            dragStartY = e.clientY;
            dragStartPosition = currentCoverPosition;
            e.preventDefault();
        }
        
        function handleDrag(e) {
            if (!isDragging) return;
            
            e.preventDefault(); // Prevent text selection during drag
            
            const heroBackground = document.getElementById('heroBackground');
            if (!heroBackground) return;
            
            const deltaY = e.clientY - dragStartY;
            const heightPercent = (deltaY / heroBackground.offsetHeight) * 100;
            
            let newPosition = dragStartPosition + heightPercent;
            newPosition = Math.max(0, Math.min(100, newPosition));
            
            // Throttle updates for stability
            requestAnimationFrame(() => {
                setCoverPosition(newPosition);
            });
        }
        
        function stopDrag() {
            isDragging = false;
        }
        
        function adjustCoverPosition(delta) {
            let newPosition = currentCoverPosition + delta;
            newPosition = Math.max(0, Math.min(100, newPosition));
            
            setCoverPosition(newPosition);
            
            // Update slider
            const slider = document.getElementById('positionSlider');
            if (slider) {
                slider.value = newPosition;
            }
        }
        
        function setCoverPosition(position) {
            currentCoverPosition = parseFloat(position);
            const heroBackground = document.getElementById('heroBackground');
            
            if (heroBackground) {
                // Remove transition during drag for stability
                heroBackground.style.transition = 'none';
                heroBackground.style.backgroundPosition = `center ${currentCoverPosition}%`;
            }
            
            // Update slider if called from drag
            const slider = document.getElementById('positionSlider');
            if (slider && Math.abs(slider.value - currentCoverPosition) > 0.1) {
                slider.value = currentCoverPosition;
            }
        }
        
        async function saveCoverPosition() {
            try {
                console.log('Saving cover position:', currentCoverPosition);
                
                // Show saving indicator
                const saveBtn = document.querySelector('.save-position-btn');
                if (saveBtn) {
                    saveBtn.textContent = 'Saving...';
                    saveBtn.disabled = true;
                }
                
                // Check if project ID is available
                if (!window.currentEvent || !window.currentEvent.id) {
                    console.error('Project ID not available');
                    showNotification('Unable to save: Project information not loaded.', 'error');
                    if (saveBtn) {
                        saveBtn.textContent = 'Save Position';
                        saveBtn.disabled = false;
                    }
                    return;
                }
                
                // Check if Supabase client is available
                if (!window.dcfSupabase) {
                    console.error('Supabase client not initialized');
                    showNotification('Unable to save: Database connection not available. Please refresh the page.', 'error');
                    if (saveBtn) {
                        saveBtn.textContent = 'Save Position';
                        saveBtn.disabled = false;
                    }
                    return;
                }
                
                // Save position to database as CSS background-position value
                const positionValue = `center ${currentCoverPosition}%`;
                
                // Verify project exists before updating
                const { data: projectCheck, error: checkError } = await window.dcfSupabase
                    .from('projects')
                    .select('id')
                    .eq('id', window.currentEvent.id)
                    .single();
                
                if (checkError || !projectCheck) {
                    console.error('Project verification failed:', checkError);
                    showNotification('Project not found. Please refresh the page.', 'error');
                    if (saveBtn) {
                        saveBtn.textContent = 'Save Position';
                        saveBtn.disabled = false;
                    }
                    return;
                }
                
                // Update the cover position
                const { data: updateData, error: updateError } = await window.dcfSupabase
                    .from('projects')
                    .update({ 
                        cover_position: positionValue
                    })
                    .eq('id', window.currentEvent.id)
                    .select();
                
                if (updateError) {
                    console.error('Error updating cover position:', updateError);
                    showNotification(`Failed to save: ${updateError.message || 'Database error'}`, 'error');
                    if (saveBtn) {
                        saveBtn.textContent = 'Save Position';
                        saveBtn.disabled = false;
                    }
                    return;
                }
                
                console.log('✅ Cover position saved to database:', positionValue);
                
                // Update local data for current session
                window.currentEvent.cover_position = positionValue;
                originalPosition = currentCoverPosition; // Update original position so cancel won't revert
                
                // Show success notification
                showNotification('Cover position saved successfully!', 'success');
                
                // Exit reposition mode after a short delay
                setTimeout(() => {
                    exitRepositionMode();
                }, 1000);
                
            } catch (error) {
                console.error('Error saving cover position:', error);
                showNotification('Failed to save cover position: ' + error.message, 'error');
                const saveBtn = document.querySelector('.save-position-btn');
                if (saveBtn) {
                    saveBtn.textContent = 'Save Position';
                    saveBtn.disabled = false;
                }
            }
        }
        
        function cancelRepositioning() {
            console.log('Canceling reposition, reverting to:', originalPosition);
            
            // Revert to original position
            setCoverPosition(originalPosition);
            
            // Exit reposition mode
            exitRepositionMode();
        }
        
        function exitRepositionMode() {
            const controls = document.getElementById('coverPositionControls');
            const heroBackground = document.getElementById('heroBackground');
            
            if (controls) {
                controls.style.display = 'none';
            }
            
            if (heroBackground) {
                heroBackground.classList.remove('repositioning');
                // Re-enable transitions
                heroBackground.style.transition = '';
            }
            
            // Disable drag
            disableDragToReposition();
            
            // Reset save button state
            const saveBtn = document.querySelector('.save-position-btn');
            if (saveBtn) {
                saveBtn.textContent = 'Save Position';
                saveBtn.disabled = false;
            }
        }
        
        // Apply saved position on page load
        function applySavedCoverPosition() {
            if (window.currentEvent && window.currentEvent.id) {
                const heroBackground = document.getElementById('heroBackground');
                if (heroBackground) {
                    // Load position from database (already fetched with project data)
                    if (window.currentEvent.cover_position) {
                        // Parse the CSS value (e.g., "center 75%")
                        const match = window.currentEvent.cover_position.match(/center\s+(\d+)%/);
                        if (match) {
                            const position = parseFloat(match[1]);
                            heroBackground.style.backgroundPosition = window.currentEvent.cover_position;
                            currentCoverPosition = position;
                            console.log('Applied saved cover position from database:', window.currentEvent.cover_position);
                        } else {
                            // If format is unexpected, just apply it directly
                            heroBackground.style.backgroundPosition = window.currentEvent.cover_position;
                            currentCoverPosition = 50; // Default for slider
                            console.log('Applied cover position (direct):', window.currentEvent.cover_position);
                        }
                    } else {
                        // Default to center if no saved position
                        const defaultPosition = 50;
                        heroBackground.style.backgroundPosition = `center ${defaultPosition}%`;
                        currentCoverPosition = defaultPosition;
                        console.log('No saved position found, using default:', defaultPosition);
                    }
                }
            }
        }
        
        // Add this to the page initialization
        document.addEventListener('DOMContentLoaded', function() {
            // Apply saved position after a short delay to ensure project data is loaded
            setTimeout(applySavedCoverPosition, 500);
        });
        
        // ============= POSTS FUNCTIONALITY - Added from member profile =============

        // Global variables for posts
        let selectedPostFiles = [];

        // Get current user helper
        function getCurrentUser() {
            return window.dcfUser?.isLoggedIn ? window.dcfUser.profile : null;
        }

        // Show notification
        function showNotification(message, type = 'success') {
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.textContent = message;
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.classList.add('show');
            }, 10);
            
            setTimeout(() => {
                notification.classList.remove('show');
                setTimeout(() => notification.remove(), 300);
            }, 3000);
        }

        // Initialize post creation
        function initializePostCreation() {
            console.log('🚀 initializePostCreation starting...');
            
            // Debug: Check user data availability
            console.log('User check via getCurrentUser():', getCurrentUser());
            console.log('window.dcfUser:', window.dcfUser);
            console.log('window.dcfUser.profile:', window.dcfUser?.profile);
            console.log('window.dcfUser.isLoggedIn:', window.dcfUser?.isLoggedIn);
            
            const mediaInput = document.getElementById('mediaFileInput');
            const textarea = document.getElementById('postTextarea');
            const submitBtn = document.getElementById('postSubmitBtnExpanded');
            const characterCount = document.getElementById('characterCount');
            const authorAvatar = document.getElementById('postAuthorAvatar');
            const authorName = document.getElementById('postAuthorName');
            
            if (!textarea || !submitBtn) {
                console.log('⚠️ Post creation elements not found, aborting');
                return;
            }
            
            // Update placeholder
            textarea.placeholder = "What's on your mind about this project?";
            
            // Add input listener (only once)
            if (!textarea.hasAttribute('data-listener-added')) {
                textarea.addEventListener('input', handlePostInput);
                textarea.setAttribute('data-listener-added', 'true');
            }
            
            // Initialize media file input (only once)
            if (mediaInput && !mediaInput.hasAttribute('data-listener-added')) {
                mediaInput.addEventListener('change', function(e) {
                    const files = Array.from(e.target.files);
                    if (files.length > 0) {
                        handlePostFileUpload(files);
                    }
                });
                mediaInput.setAttribute('data-listener-added', 'true');
            }
            
            // Update user display
            updatePostCreationUserDisplay();
        }
        
        // Update comment form avatars to match post creation avatar logic
        function updateCommentFormAvatars() {
            // Get current user (same as post creation)
            let currentUser = getCurrentUser();
            if (!currentUser && window.dcfUser && window.dcfUser.isLoggedIn) {
                currentUser = window.dcfUser.profile;
            }
            
            // Find all comment form avatars
            const commentAvatars = document.querySelectorAll('[id^="commentAvatar-"]');
            
            commentAvatars.forEach(avatar => {
                if (currentUser) {
                    if (currentUser.avatar_url) {
                        // User has profile picture - use exact same logic as post creation
                        avatar.style.background = `url(${currentUser.avatar_url}) center/cover`;
                        avatar.textContent = '';
                    } else {
                        // Generate initials - exact same logic as post creation
                        let initials = '';
                        if (currentUser.first_name && currentUser.last_name) {
                            initials = currentUser.first_name[0] + currentUser.last_name[0];
                        } else if (currentUser.username) {
                            initials = currentUser.username.substring(0, 2);
                        } else if (currentUser.email) {
                            initials = currentUser.email.substring(0, 2);
                        } else {
                            initials = 'U';
                        }
                        avatar.style.background = 'linear-gradient(135deg, #667eea, #764ba2)';
                        avatar.style.color = 'white';
                        avatar.style.display = 'flex';
                        avatar.style.alignItems = 'center';
                        avatar.style.justifyContent = 'center';
                        avatar.style.fontWeight = '600';
                        avatar.textContent = initials.toUpperCase();
                    }
                } else {
                    // Not logged in - show guest indicator
                    avatar.style.background = 'linear-gradient(135deg, #667eea, #764ba2)';
                    avatar.style.color = 'white';
                    avatar.style.display = 'flex';
                    avatar.style.alignItems = 'center';
                    avatar.style.justifyContent = 'center';
                    avatar.style.fontWeight = '600';
                    avatar.textContent = 'G';
                }
            });
        }

        // Separate function to update user display that can be called later
        function updatePostCreationUserDisplay() {
            console.log('📝 Updating post creation user display...');
            
            const authorAvatar = document.getElementById('postAuthorAvatar');
            const authorName = document.getElementById('postAuthorName');
            const textarea = document.getElementById('postTextarea');
            
            // Try to get current user
            let currentUser = getCurrentUser();
            
            // Fallback to dcfUser if getCurrentUser returns null
            if (!currentUser && window.dcfUser && window.dcfUser.isLoggedIn) {
                currentUser = window.dcfUser.profile;
            }
            
            console.log('Current user found:', currentUser);
            
            if (currentUser) {
                // Update author name
                if (authorName) {
                    const displayName = currentUser.username || 
                                      currentUser.email?.split('@')[0] || 
                                      'user';
                    authorName.textContent = `@${displayName}`;
                    authorName.style.color = '#333';
                    console.log('Set author name to:', `@${displayName}`);
                }
                
                // Update avatar
                if (authorAvatar) {
                    if (currentUser.avatar_url) {
                        console.log('Setting avatar image:', currentUser.avatar_url);
                        authorAvatar.style.backgroundImage = `url(${currentUser.avatar_url})`;
                        authorAvatar.style.backgroundSize = 'cover';
                        authorAvatar.style.backgroundPosition = 'center';
                        authorAvatar.style.background = `url(${currentUser.avatar_url}) center/cover`;
                        authorAvatar.textContent = '';
                    } else {
                        // Generate initials
                        let initials = '';
                        if (currentUser.first_name && currentUser.last_name) {
                            initials = currentUser.first_name[0] + currentUser.last_name[0];
                        } else if (currentUser.username) {
                            initials = currentUser.username.substring(0, 2);
                        } else if (currentUser.email) {
                            initials = currentUser.email.substring(0, 2);
                        } else {
                            initials = 'U';
                        }
                        
                        console.log('Setting avatar initials:', initials.toUpperCase());
                        authorAvatar.style.backgroundImage = '';
                        authorAvatar.style.background = 'linear-gradient(135deg, #667eea, #764ba2)';
                        authorAvatar.style.color = 'white';
                        authorAvatar.style.display = 'flex';
                        authorAvatar.style.alignItems = 'center';
                        authorAvatar.style.justifyContent = 'center';
                        authorAvatar.style.fontWeight = '600';
                        authorAvatar.textContent = initials.toUpperCase();
                    }
                }
                
                // Update placeholder with user's name
                if (textarea) {
                    const firstName = currentUser.first_name || 
                                    currentUser.username || 
                                    'there';
                    textarea.placeholder = `What's on your mind, ${firstName}?`;
                }
            } else {
                console.log('⚠️ No user found, showing default state');
                
                // Not logged in - show default state
                if (authorName) {
                    authorName.textContent = 'Sign in to post';
                    authorName.style.color = '#999';
                }
                
                if (authorAvatar) {
                    authorAvatar.style.backgroundImage = '';
                    authorAvatar.style.background = 'linear-gradient(135deg, #667eea, #764ba2)';
                    authorAvatar.style.color = 'white';
                    authorAvatar.style.display = 'flex';
                    authorAvatar.style.alignItems = 'center';
                    authorAvatar.style.justifyContent = 'center';
                    authorAvatar.style.fontWeight = '600';
                    authorAvatar.textContent = 'G';  // G for Guest
                }
                
                if (textarea) {
                    textarea.placeholder = 'Sign in to share your thoughts about this project...';
                }
            }
        }

        // Handle post input
        function handlePostInput() {
            const textarea = document.getElementById('postTextarea');
            const submitBtn = document.getElementById('postSubmitBtnExpanded');
            const characterCount = document.getElementById('characterCount');
            
            if (!textarea || !submitBtn) return;
            
            const content = textarea.value.trim();
            const charCount = textarea.value.length;
            
            if (characterCount) {
                characterCount.textContent = `${charCount}/2000`;
                if (charCount > 1800) {
                    characterCount.style.color = '#dc3545';
                } else if (charCount > 1500) {
                    characterCount.style.color = '#ffc107';
                } else {
                    characterCount.style.color = '#666';
                }
            }
            
            submitBtn.disabled = content.length === 0 || charCount > 2000;
        }

        // Submit post
        async function submitPost() {
            const textarea = document.getElementById('postTextarea');
            const content = textarea.value.trim();
            const projectId = new URLSearchParams(window.location.search).get('id');
            const currentUser = getCurrentUser();
            
            if (!currentUser) {
                showNotification('Please log in to create posts', 'warning');
                return;
            }
            
            if (!content) {
                showNotification('Please enter some content for your post', 'warning');
                return;
            }
            
            if (!projectId) {
                showNotification('Invalid project URL', 'error');
                return;
            }
            
            // Authorization check: Verify user can post to this project
            if (window.currentEvent) {
                const isProjectAuthor = currentUser.id === window.currentEvent.author_id;
                
                // For now, allow project author and all logged-in users to post
                // Later can restrict to only project members if needed
                if (!isProjectAuthor && window.currentEvent.posts_restricted) {
                    // If project has restricted posting (future feature)
                    showNotification('You are not authorized to post to this project', 'error');
                    return;
                }
                
                console.log('User authorized to post:', {
                    userId: currentUser.id,
                    projectAuthorId: window.currentEvent.author_id,
                    isProjectAuthor: isProjectAuthor
                });
            }
            
            try {
                let mediaUrls = [];
                if (selectedPostFiles && selectedPostFiles.length > 0) {
                    try {
                        mediaUrls = await uploadPostMedia(selectedPostFiles);
                    } catch (error) {
                        console.error('Media upload failed:', error);
                        showNotification('Failed to upload media files', 'error');
                        return;
                    }
                }

                const { data, error } = await window.dcfSupabase
                    .from('posts')
                    .insert({
                        author_id: currentUser.id,
                        author_email: currentUser.email,
                        author_name: `@${currentUser.username}`,
                        username: currentUser.username,
                        content: content,
                        context_type: 'project',
                        context_id: projectId,
                        media_url: mediaUrls.length > 0 ? JSON.stringify(mediaUrls) : null,
                        media_count: mediaUrls.length,
                        media_type: mediaUrls.length > 0 ? 
                            (selectedPostFiles[0].type.startsWith('image/') ? 'images' : 'video') : null
                    })
                    .select()
                    .single();
                    
                if (error) throw error;
                
                textarea.value = '';
                handlePostInput();
                showNotification('Post created successfully!');
                
                // Clear media selection after successful post
                removePostFiles();
                
                // Add post to feed immediately
                addPostToFeed(data);
                
            } catch (error) {
                console.error('Error creating post:', error);
                showNotification('Failed to create post. Please try again.', 'error');
            }
        }

        // Add post to feed
        function addPostToFeed(post) {
            const feedContainer = document.getElementById('postsFeed');
            if (!feedContainer) return;
            
            const postHTML = createPostHTML(post);
            
            // Remove loading message if it exists
            const loadingMsg = feedContainer.querySelector('.loading-posts');
            if (loadingMsg) {
                loadingMsg.remove();
            }
            
            // Add new post at the top
            feedContainer.insertAdjacentHTML('afterbegin', postHTML);
        }

        // Format time ago
        function formatTimeAgo(dateString) {
            const now = new Date();
            const postDate = new Date(dateString);
            const diffInSeconds = Math.floor((now - postDate) / 1000);
            
            if (diffInSeconds < 60) return 'Just now';
            if (diffInSeconds < 3600) return `${Math.floor(diffInSeconds / 60)}m ago`;
            if (diffInSeconds < 86400) return `${Math.floor(diffInSeconds / 3600)}h ago`;
            return `${Math.floor(diffInSeconds / 86400)}d ago`;
        }

        // Linkify text
        function linkifyText(text) {
            if (!text) return '';
            
            // Escape HTML to prevent XSS
            const escapeHtml = (str) => {
                const div = document.createElement('div');
                div.textContent = str;
                return div.innerHTML;
            };
            
            let escapedText = escapeHtml(text);
            
            // Convert URLs to clickable links
            const urlPattern = /(https?:\/\/[^\s]+)/g;
            escapedText = escapedText.replace(urlPattern, '<a href="$1" target="_blank" rel="noopener">$1</a>');
            
            return escapedText;
        }

        // Create post HTML
        function createPostHTML(post) {
            const timeAgo = formatTimeAgo(post.created_at);
            const authorName = post.author_name || `@${post.username}`;
            const currentUser = getCurrentUser();
            
            // Generate avatar HTML - use cached avatar data
            let avatarHTML = '';
            const postAvatarUrl = userAvatarCache[post.author_id];
            
            // First check if post author has avatar
            if (postAvatarUrl) {
                avatarHTML = `<div class="post-avatar" style="background-image: url(${postAvatarUrl}); background-size: cover; background-position: center;"></div>`;
            } 
            // Fallback to current user's avatar if it's their post and not cached
            else if (currentUser && currentUser.avatar_url && post.author_email === currentUser.email) {
                avatarHTML = `<div class="post-avatar" style="background-image: url(${currentUser.avatar_url}); background-size: cover; background-position: center;"></div>`;
            } 
            // Use initials as last resort
            else {
                const initials = post.username ? generateInitials(post.username) : 'UN';
                avatarHTML = `<div class="post-avatar">${initials}</div>`;
            }
            
            // Generate media HTML if post has media
            let mediaHTML = '';
            if (post.media_url && post.media_count > 0) {
                try {
                    const mediaUrls = JSON.parse(post.media_url);
                    if (mediaUrls && mediaUrls.length > 0) {
                        if (post.media_type === 'video') {
                            mediaHTML = `
                                <div class="post-media" style="margin: 1rem 0;">
                                    <video src="${mediaUrls[0]}" style="width: 100%; max-width: 500px; border-radius: 12px; border: 2px solid #e5e5e5;" controls></video>
                                </div>
                            `;
                        } else {
                            // Simple image display
                            if (mediaUrls.length === 1) {
                                mediaHTML = `
                                    <div class="post-media" style="margin: 1rem 0;">
                                        <img src="${mediaUrls[0]}" style="max-width: 100%; border-radius: 12px; cursor: pointer;" onclick="openImageModal('${mediaUrls[0]}'); event.stopPropagation();">
                                    </div>
                                `;
                            } else {
                                // Multiple images grid
                                mediaHTML = `<div class="post-media" style="margin: 1rem 0; display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 0.5rem;">`;
                                mediaUrls.forEach((url, index) => {
                                    mediaHTML += `<img src="${url}" style="width: 100%; border-radius: 8px; cursor: pointer;" onclick="openImageGallery(${JSON.stringify(mediaUrls).replace(/"/g, "'")}, ${index}); event.stopPropagation();">`;
                                });
                                mediaHTML += `</div>`;
                            }
                        }
                    }
                } catch (e) {
                    console.error('Error parsing media URLs:', e);
                }
            }
            
            return `
                <div class="post-card" data-post-id="${post.id}">
                    <div class="post-header">
                        <div class="post-author">
                            ${avatarHTML}
                            <div class="post-author-info">
                                <h4>${authorName}</h4>
                                <div class="post-date">${timeAgo}</div>
                            </div>
                        </div>
                    </div>
                    <div class="post-content">${linkifyText(post.content)}</div>
                    ${mediaHTML}
                    <div class="post-actions">
                        <button class="post-action-btn" onclick="toggleLike('${post.id}')" id="like-btn-${post.id}">
                            🤍 Like (${post.like_count || 0})
                        </button>
                        <button class="post-action-btn" onclick="sharePost('${post.id}')">
                            📤 Share
                        </button>
                        ${post.author_email === currentUser?.email ? `
                            <div style="margin-left: auto; display: flex; gap: 0.5rem;">
                                <button class="post-action-btn" onclick="toggleInlineEdit('${post.id}')" style="color: #007bff;">
                                    ✏️ Edit
                                </button>
                                <button class="post-action-btn" onclick="deletePost('${post.id}')" style="color: #dc3545;">
                                    🗑️ Delete
                                </button>
                            </div>
                        ` : ''}
                    </div>
                    
                    <!-- COMMENTS SECTION FOR POST -->
                    <div class="comments-section">
                        <div class="section-title">
                            💬 Comments (<span id="totalComments-${post.id}">0</span>)
                        </div>
                        
                        <!-- Comment Sorting Controls -->
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; padding: 0.75rem 0; border-bottom: 1px solid #e9ecef;">
                            <div style="display: flex; gap: 0.5rem;">
                                <button class="sort-btn active" data-sort="newest" onclick="sortComments('newest', '${post.id}')" style="background: linear-gradient(135deg, #000, #333); color: white; border: none; padding: 0.4rem 0.8rem; border-radius: 6px; font-size: 0.8rem; cursor: pointer; font-weight: 500;">
                                    Newest First
                                </button>
                                <button class="sort-btn" data-sort="oldest" onclick="sortComments('oldest', '${post.id}')" style="background: #f8f9fa; color: #666; border: 1px solid #e5e5e5; padding: 0.4rem 0.8rem; border-radius: 6px; font-size: 0.8rem; cursor: pointer; font-weight: 500;">
                                    Oldest First
                                </button>
                                <button class="sort-btn" data-sort="liked" onclick="sortComments('liked', '${post.id}')" style="background: #f8f9fa; color: #666; border: 1px solid #e5e5e5; padding: 0.4rem 0.8rem; border-radius: 6px; font-size: 0.8rem; cursor: pointer; font-weight: 500;">
                                    Most Liked
                                </button>
                                <button class="sort-btn" data-sort="replies" onclick="sortComments('replies', '${post.id}')" style="background: #f8f9fa; color: #666; border: 1px solid #e5e5e5; padding: 0.4rem 0.8rem; border-radius: 6px; font-size: 0.8rem; cursor: pointer; font-weight: 500;">
                                    Most Replies
                                </button>
                            </div>
                        </div>
                        
                        <!-- Enhanced Comment form -->
                        <div id="commentForm-${post.id}" class="comment-form">
                            <div style="display: flex; gap: 0.75rem;">
                                <div class="comment-avatar" id="commentAvatar-${post.id}" style="${currentUser && currentUser.avatar_url ? `background: url(${currentUser.avatar_url}) center/cover;` : ''}">
                                    ${currentUser && currentUser.avatar_url ? '' : (currentUser && currentUser.first_name && currentUser.last_name ? (currentUser.first_name[0] + currentUser.last_name[0]).toUpperCase() : (currentUser && currentUser.username ? generateInitials(currentUser.username) : 'U'))}
                                </div>
                                <div style="flex: 1;">
                                    <textarea id="commentText-${post.id}" class="comment-textarea" placeholder="Write a comment..."></textarea>
                                    <div style="display: flex; justify-content: space-between; align-items: center;">
                                        <div class="comment-helper-text">Be respectful and constructive</div>
                                        <button class="comment-submit-btn" onclick="submitPostComment('${post.id}')">
                                            Post Comment
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Comments list -->
                        <div id="commentsList-${post.id}" class="comments-list">
                            <div class="comments-empty">No comments yet</div>
                        </div>
                    </div>
                </div>
            `;
        }

        // Load posts feed
        async function loadPostsFeed() {
            const feedContainer = document.getElementById('postsFeed');
            if (!feedContainer) return;
            
            // Get event ID from URL
            const eventId = new URLSearchParams(window.location.search).get('id');
            if (!eventId) {
                console.error('No event ID found in URL');
                feedContainer.innerHTML = '<div style="text-align: center; padding: 2rem; color: #dc3545;">Invalid event URL</div>';
                return;
            }
            
            console.log('Loading announcements for event:', eventId);
            
            try {
                // Load event announcements
                const { data: posts, error } = await window.dcfSupabase
                    .from('event_announcements')
                    .select('*')
                    .eq('event_id', eventId)
                    .neq('status', 'deleted')        // Exclude deleted posts
                    .order('created_at', { ascending: false })
                    .limit(50);
                    
                if (error) {
                    console.error('Database error:', error);
                    throw error;
                }
                
                console.log(`Found ${posts?.length || 0} posts for project ${projectId}`);
                
                // Fetch avatars for all post authors
                if (posts && posts.length > 0) {
                    const uniquePostAuthorIds = [...new Set(posts.map(p => p.author_id).filter(id => id))];
                    await Promise.all(uniquePostAuthorIds.map(id => fetchUserAvatar(id)));
                }
                
                if (!posts || posts.length === 0) {
                    feedContainer.innerHTML = '<div style="text-align: center; padding: 2rem; color: #666;">No posts yet. Be the first to share something about this project!</div>';
                    return;
                }
                
                // Double-check: filter again in JavaScript as safety measure
                const projectPosts = posts.filter(post => 
                    post.context_type === 'project' && 
                    post.context_id === projectId
                );
                
                if (projectPosts.length === 0) {
                    feedContainer.innerHTML = '<div style="text-align: center; padding: 2rem; color: #666;">No posts yet. Be the first to share something about this project!</div>';
                    return;
                }
                
                feedContainer.innerHTML = projectPosts.map(post => createPostHTML(post)).join('');
                
                // After posts are loaded, check like statuses and load comments
                setTimeout(() => {
                    if (window.loadUserLikeStatuses) {
                        loadUserLikeStatuses();
                    }
                    
                    // Update comment form avatars with proper user data
                    updateCommentFormAvatars();
                    
                    // Load comments for each post
                    projectPosts.forEach(post => {
                        loadPostComments(post.id);
                    });
                }, 500);
                
            } catch (error) {
                console.error('Error loading posts:', error);
                feedContainer.innerHTML = '<div style="text-align: center; padding: 2rem; color: #dc3545;">Failed to load posts for this project</div>';
            }
        }

        // Validate file selection
        function validateFileSelection(files) {
            const videoTypes = ['video/mp4', 'video/quicktime', 'video/x-msvideo', 'video/webm'];
            const videoFiles = Array.from(files).filter(file => videoTypes.includes(file.type));
            const nonVideoFiles = Array.from(files).filter(file => !videoTypes.includes(file.type));
            
            // Only 1 video file allowed
            if (videoFiles.length > 1) {
                showAlert('Only one video file can be uploaded at a time.', 'warning');
                return false;
            }
            
            if (videoFiles.length === 1 && files.length > 1) {
                showAlert('Videos can only be uploaded one at a time.', 'warning');
                return false;
            }
            
            // Up to 4 non-video files allowed
            if (videoFiles.length === 0 && files.length > 4) {
                showAlert('Maximum 4 files allowed for images.', 'warning');
                return false;
            }
            
            // Check file size limits
            for (const file of files) {
                let maxSize;
                if (file.type.startsWith('video/')) {
                    maxSize = 50 * 1024 * 1024; // 50MB for videos
                } else if (file.type.startsWith('image/')) {
                    maxSize = 5 * 1024 * 1024; // 5MB for images
                } else {
                    showAlert('Only images and videos are allowed.', 'warning');
                    return false;
                }
                
                if (file.size > maxSize) {
                    const sizeMB = Math.round(maxSize / (1024 * 1024));
                    showAlert(`File too large. Max ${sizeMB}MB for ${file.type.startsWith('video/') ? 'videos' : 'images'}.`, 'warning');
                    return false;
                }
            }
            
            return true;
        }

        // Upload post media
        async function uploadPostMedia(files) {
            const currentUser = getCurrentUser();
            if (!currentUser) throw new Error('User not authenticated');
            
            const supabase = window.dcfSupabase;
            const uploadedUrls = [];
            
            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                const fileName = `post_${currentUser.id}_${Date.now()}_${i}.${file.name.split('.').pop()}`;
                
                const { data, error } = await supabase.storage
                    .from('media')
                    .upload(fileName, file, {
                        cacheControl: '3600',
                        upsert: true
                    });
                
                if (error) throw error;
                
                const { data: urlData } = supabase.storage
                    .from('media')
                    .getPublicUrl(fileName);
                
                uploadedUrls.push(urlData.publicUrl);
            }
            
            console.log('Uploaded URLs:', uploadedUrls);
            return uploadedUrls;
        }

        // Validate file selection
        function validateFileSelection(files) {
            const videoTypes = ['video/mp4', 'video/quicktime', 'video/x-msvideo', 'video/webm'];
            const videoFiles = Array.from(files).filter(file => videoTypes.includes(file.type));
            const nonVideoFiles = Array.from(files).filter(file => !videoTypes.includes(file.type));
            
            // Rule 1: Only 1 video file allowed, and no other files with videos
            if (videoFiles.length > 1) {
                showUploadError('Only one video file can be uploaded at a time.');
                return false;
            }
            
            if (videoFiles.length === 1 && files.length > 1) {
                showUploadError('Videos can only be uploaded one at a time. Please select only the video file.');
                return false;
            }
            
            // Rule 2: Up to 4 non-video files allowed
            if (videoFiles.length === 0 && files.length > 4) {
                showUploadError('Maximum 4 files allowed for images and documents.');
                return false;
            }
            
            // Rule 3: Check individual file size limits
            for (const file of files) {
                let maxSize;
                if (file.type.startsWith('video/')) {
                    maxSize = 50 * 1024 * 1024; // 50MB for videos
                } else if (file.type.startsWith('image/')) {
                    maxSize = 5 * 1024 * 1024; // 5MB for images
                } else {
                    showUploadError('Only images and videos are allowed for posts.');
                    return false;
                }
                
                if (file.size > maxSize) {
                    const maxSizeMB = maxSize / (1024 * 1024);
                    showUploadError(`File "${file.name}" exceeds the ${maxSizeMB}MB limit.`);
                    return false;
                }
            }
            
            return true;
        }

        // Animate progress bar
        function animateProgress(from, to, duration) {
            const progressFill = document.getElementById('postUploadProgressFill');
            const startTime = Date.now();
            
            function updateProgress() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const currentValue = from + (to - from) * progress;
                
                progressFill.style.width = currentValue + '%';
                
                if (progress < 1) {
                    requestAnimationFrame(updateProgress);
                }
            }
            
            updateProgress();
        }

        // Create post file preview
        function createPostFilePreview(files) {
            const previewDiv = document.getElementById('postFilePreview');
            previewDiv.innerHTML = '';
            
            if (files.length === 1) {
                const file = files[0];
                const fileSize = (file.size / 1024 / 1024).toFixed(2);
                
                if (file.type.startsWith('image/')) {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        previewDiv.innerHTML = `
                            <div style="margin-top: 1rem; position: relative; display: inline-block;">
                                <img src="${e.target.result}" style="display: block; width: 100%; max-width: 400px; border-radius: 12px; border: 2px solid #e5e5e5;">
                                <button type="button" onclick="removePostFiles()" style="position: absolute; top: 10px; right: 10px; width: 32px; height: 32px; border-radius: 50%; background: rgba(220, 53, 69, 0.95); color: white; border: 2px solid white; cursor: pointer; font-size: 18px; font-weight: bold; z-index: 10; box-shadow: 0 2px 8px rgba(0,0,0,0.4); display: flex; align-items: center; justify-content: center; line-height: 1;">×</button>
                            </div>
                        `;
                    };
                    reader.readAsDataURL(file);
                } else if (file.type.startsWith('video/')) {
                    const videoUrl = URL.createObjectURL(file);
                    previewDiv.innerHTML = `
                        <div style="margin-top: 1rem; position: relative; display: inline-block;">
                            <video src="${videoUrl}" style="display: block; width: 100%; max-width: 400px; border-radius: 12px;" controls></video>
                            <button type="button" onclick="removePostFiles()" style="position: absolute; top: 10px; right: 10px; width: 32px; height: 32px; border-radius: 50%; background: rgba(220, 53, 69, 0.95); color: white; border: 2px solid white; cursor: pointer; font-size: 18px; font-weight: bold; z-index: 10; box-shadow: 0 2px 8px rgba(0,0,0,0.4); display: flex; align-items: center; justify-content: center; line-height: 1;">×</button>
                        </div>
                    `;
                }
            } else {
                // Multiple images grid
                let gridHTML = `<div style="margin-top: 1rem; display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 1rem; max-width: 600px;">`;
                
                files.forEach((file, index) => {
                    if (file.type.startsWith('image/')) {
                        gridHTML += `<div id="post-preview-${index}" style="position: relative;"></div>`;
                    }
                });
                
                gridHTML += '</div>';
                previewDiv.innerHTML = gridHTML;
                
                // Load images
                files.forEach((file, index) => {
                    if (file.type.startsWith('image/')) {
                        const reader = new FileReader();
                        reader.onload = function(e) {
                            const imageDiv = document.getElementById(`post-preview-${index}`);
                            if (imageDiv) {
                                imageDiv.innerHTML = `
                                    <div style="position: relative; display: inline-block;">
                                        <img src="${e.target.result}" style="display: block; width: 150px; height: 150px; object-fit: cover; border-radius: 8px; border: 2px solid #e5e5e5;">
                                        <button type="button" onclick="removePostFile(${index})" style="position: absolute; top: 6px; right: 6px; width: 26px; height: 26px; border-radius: 50%; background: rgba(220, 53, 69, 0.95); color: white; border: 2px solid white; cursor: pointer; font-size: 14px; font-weight: bold; z-index: 10; box-shadow: 0 2px 6px rgba(0,0,0,0.4); display: flex; align-items: center; justify-content: center; line-height: 1;">×</button>
                                    </div>
                                `;
                            }
                        };
                        reader.readAsDataURL(file);
                    }
                });
            }
        }

        // Handle post file upload
        function handlePostFileUpload(files) {
            if (!validateFileSelection(files)) {
                return;
            }
            
            const progressBar = document.getElementById('postUploadProgress');
            const statusDiv = document.getElementById('postUploadStatus');
            
            progressBar.style.display = 'block';
            statusDiv.style.display = 'block';
            statusDiv.textContent = `Processing ${files.length} file${files.length > 1 ? 's' : ''}...`;
            
            animateProgress(0, 100, 1500);
            
            setTimeout(() => {
                selectedPostFiles = files;
                createPostFilePreview(files);
                
                statusDiv.style.color = '#28a745';
                statusDiv.textContent = `✓ ${files.length} file${files.length > 1 ? 's' : ''} ready`;
                
                setTimeout(() => {
                    progressBar.style.display = 'none';
                    statusDiv.style.display = 'none';
                }, 1000);
            }, 1500);
        }

        // Remove all post files
        function removePostFiles() {
            selectedPostFiles = [];
            document.getElementById('postFilePreview').innerHTML = '';
            document.getElementById('mediaFileInput').value = '';
        }

        // Remove single post file
        function removePostFile(index) {
            selectedPostFiles.splice(index, 1);
            if (selectedPostFiles.length === 0) {
                removePostFiles();
            } else {
                createPostFilePreview(selectedPostFiles);
            }
        }

        // Show upload error
        function showUploadError(message) {
            const statusDiv = document.getElementById('postUploadStatus');
            statusDiv.style.display = 'block';
            statusDiv.style.color = '#dc3545';
            statusDiv.textContent = '✗ ' + message;
            document.getElementById('mediaFileInput').value = '';
        }

        // POST EDIT/DELETE FUNCTIONS
        async function deletePost(postId) {
            if (!await showConfirm('Are you sure you want to delete this post? This action cannot be undone.')) {
                return;
            }
            
            try {
                // Show loading state
                showNotification('Deleting post...', 'info');
                
                const { error } = await window.dcfSupabase
                    .from('posts')
                    .delete()
                    .eq('id', postId);
                    
                if (error) throw error;
                
                // Remove post from UI immediately for smooth UX
                const postElement = document.querySelector(`[data-post-id="${postId}"]`);
                if (postElement) {
                    postElement.style.transition = 'opacity 0.3s, transform 0.3s';
                    postElement.style.opacity = '0';
                    postElement.style.transform = 'scale(0.95)';
                    setTimeout(() => postElement.remove(), 300);
                }
                
                showNotification('Post deleted', 'success');
                
                // Optionally reload feed to ensure consistency
                // await loadPostsFeed();
                
            } catch (error) {
                console.error('Error deleting post:', error);
                showNotification('Failed to delete post', 'error');
                // Reload feed to restore consistency
                await loadPostsFeed();
            }
        }

        // IMAGE MODAL FUNCTIONS
        function openImageModal(imageUrl, allImageUrls = null) {
            // If multiple images, use gallery modal
            if (allImageUrls && allImageUrls.length > 1) {
                openImageGallery(allImageUrls, allImageUrls.indexOf(imageUrl));
                return;
            }
            
            const modal = document.getElementById('imageModal');
            const modalImage = document.getElementById('modalImage');
            
            if (!modal || !modalImage) {
                console.error('Image modal elements not found');
                return;
            }
            
            modalImage.src = imageUrl;
            modal.style.display = 'flex';
            
            // Smart sizing for single images
            modalImage.style.maxWidth = '90vw';
            modalImage.style.maxHeight = '90vh';
            modalImage.style.width = 'auto';
            modalImage.style.height = 'auto';
            modalImage.style.objectFit = 'contain';
            
            // Prevent body scroll
            document.body.style.overflow = 'hidden';
        }

        function closeImageModal() {
            const modal = document.getElementById('imageModal');
            if (modal) {
                modal.style.display = 'none';
                document.body.style.overflow = 'auto';
            }
        }

        // IMAGE GALLERY NAVIGATION FUNCTIONS
        let currentGalleryImages = [];
        let currentImageIndex = 0;

        function openImageGallery(imageUrls, startIndex = 0) {
            currentGalleryImages = imageUrls;
            currentImageIndex = startIndex;
            
            const modal = document.getElementById('imageGalleryModal');
            if (!modal) {
                console.error('Gallery modal not found');
                return;
            }
            
            const galleryImage = document.getElementById('galleryImage');
            const prevBtn = document.getElementById('galleryPrevBtn');
            const nextBtn = document.getElementById('galleryNextBtn');
            const counter = document.getElementById('imageCounter');
            
            // Show modal
            modal.style.display = 'flex';
            
            // Update image and UI
            updateGalleryImage();
            
            // Show/hide navigation buttons
            if (prevBtn) prevBtn.style.display = imageUrls.length > 1 ? 'block' : 'none';
            if (nextBtn) nextBtn.style.display = imageUrls.length > 1 ? 'block' : 'none';
            
            // Prevent body scroll
            document.body.style.overflow = 'hidden';
        }

        function updateGalleryImage() {
            const galleryImage = document.getElementById('galleryImage');
            const counter = document.getElementById('imageCounter');
            const prevBtn = document.getElementById('galleryPrevBtn');
            const nextBtn = document.getElementById('galleryNextBtn');
            
            if (!galleryImage) return;
            
            // Update image
            galleryImage.src = currentGalleryImages[currentImageIndex];
            
            // Update counter
            if (counter) {
                counter.textContent = `${currentImageIndex + 1} of ${currentGalleryImages.length}`;
            }
            
            // Update button states
            if (prevBtn) prevBtn.style.opacity = currentImageIndex === 0 ? '0.5' : '1';
            if (nextBtn) nextBtn.style.opacity = currentImageIndex === currentGalleryImages.length - 1 ? '0.5' : '1';
        }

        function previousImage() {
            if (currentImageIndex > 0) {
                currentImageIndex--;
                updateGalleryImage();
            }
        }

        function nextImage() {
            if (currentImageIndex < currentGalleryImages.length - 1) {
                currentImageIndex++;
                updateGalleryImage();
            }
        }

        function closeImageGallery() {
            const modal = document.getElementById('imageGalleryModal');
            if (modal) {
                modal.style.display = 'none';
                document.body.style.overflow = 'auto';
            }
        }

        // Keyboard navigation for image gallery
        document.addEventListener('keydown', function(e) {
            const modal = document.getElementById('imageGalleryModal');
            const imageModal = document.getElementById('imageModal');
            
            if (modal && modal.style.display === 'flex') {
                if (e.key === 'ArrowLeft') {
                    previousImage();
                } else if (e.key === 'ArrowRight') {
                    nextImage();
                } else if (e.key === 'Escape') {
                    closeImageGallery();
                }
            } else if (imageModal && imageModal.style.display === 'flex') {
                if (e.key === 'Escape') {
                    closeImageModal();
                }
            }
        });

        // Toggle like
        async function toggleLike(postId) {
            const currentUser = getCurrentUser();
            if (!currentUser) {
                showAlert('Please log in to like posts', 'warning');
                return;
            }
            
            // Implementation for likes would go here
            console.log('Like toggled for post:', postId);
        }

        // Share post
        function sharePost(postId) {
            const url = `${window.location.origin}${window.location.pathname}#post-${postId}`;
            navigator.clipboard.writeText(url).then(() => {
                showNotification('Link copied to clipboard!');
            });
        }

        // Edit post (placeholder)
        // INLINE EDITING FUNCTIONS
        function toggleInlineEdit(postId) {
            const postElement = document.querySelector(`[data-post-id="${postId}"]`);
            const contentDiv = postElement.querySelector('.post-content');
            
            if (contentDiv.querySelector('textarea')) {
                // Already editing - trigger save
                const saveBtn = document.querySelector(`button[onclick="saveInlineEdit('${postId}')"]`);
                if (saveBtn && !saveBtn.disabled) {
                    saveInlineEdit(postId);
                }
            } else {
                // Start editing
                startInlineEdit(postId);
            }
        }

        function startInlineEdit(postId) {
            const postElement = document.querySelector(`[data-post-id="${postId}"]`);
            const contentDiv = postElement.querySelector('.post-content');
            const editBtn = postElement.querySelector('button[onclick*="toggleInlineEdit"]');
            
            // Get current content (strip HTML links)
            const currentContent = contentDiv.textContent || contentDiv.innerText;
            
            // Create textarea with current content
            const textarea = document.createElement('textarea');
            textarea.id = `edit-textarea-${postId}`;
            textarea.value = currentContent;
            textarea.style.cssText = `
                width: 100%;
                min-height: 100px;
                padding: 1rem;
                border: 2px solid #007bff;
                border-radius: 8px;
                font-size: 1rem;
                font-family: inherit;
                resize: vertical;
                outline: none;
                background: #f8f9fa;
            `;
            
            // Create save/cancel buttons
            const buttonContainer = document.createElement('div');
            buttonContainer.style.cssText = 'margin-top: 0.5rem; display: flex; gap: 0.5rem; justify-content: flex-end;';
            buttonContainer.innerHTML = `
                <button onclick="cancelInlineEdit('${postId}')" style="padding: 0.5rem 1rem; background: #6c757d; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 0.9rem;">Cancel</button>
                <button onclick="saveInlineEdit('${postId}')" style="padding: 0.5rem 1rem; background: #007bff; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 0.9rem;">Save</button>
            `;
            
            // Store original content
            contentDiv.setAttribute('data-original-content', contentDiv.innerHTML);
            
            // Replace content with textarea
            contentDiv.innerHTML = '';
            contentDiv.appendChild(textarea);
            contentDiv.appendChild(buttonContainer);
            
            // Update edit button
            editBtn.textContent = '💾 Save';
            editBtn.style.color = '#28a745';
            
            // Focus textarea
            textarea.focus();
            textarea.setSelectionRange(textarea.value.length, textarea.value.length);
        }

        async function saveInlineEdit(postId) {
            const textarea = document.getElementById(`edit-textarea-${postId}`);
            const newContent = textarea.value.trim();
            
            if (!newContent) {
                showNotification('Post content cannot be empty', 'error');
                return;
            }
            
            if (newContent.length > 2000) {
                showNotification('Post content is too long (max 2000 characters)', 'error');
                return;
            }
            
            // Get save button and disable it
            const saveBtn = document.querySelector(`button[onclick="saveInlineEdit('${postId}')"]`);
            const originalText = saveBtn.textContent;
            saveBtn.textContent = 'Saving...';
            saveBtn.disabled = true;
            
            try {
                const { data, error } = await window.dcfSupabase
                    .from('posts')
                    .update({ 
                        content: newContent,
                        updated_at: new Date().toISOString()
                    })
                    .eq('id', postId)
                    .select()
                    .single();
                    
                if (error) {
                    console.error('Error updating post:', error);
                    throw error;
                }
                
                // Update post content
                const postElement = document.querySelector(`[data-post-id="${postId}"]`);
                const contentDiv = postElement.querySelector('.post-content');
                const editBtn = postElement.querySelector('button[onclick*="toggleInlineEdit"]');
                
                // Restore content with linkified text
                contentDiv.innerHTML = linkifyText(newContent);
                
                // Update edit button
                editBtn.innerHTML = '✏️ Edit';
                editBtn.style.color = '#007bff';
                
                // Add edited indicator
                const postDate = postElement.querySelector('.post-date');
                if (postDate && !postDate.textContent.includes('(edited)')) {
                    postDate.textContent += ' (edited)';
                }
                
                showNotification('Post updated successfully', 'success');
                
            } catch (error) {
                console.error('Error saving post edit:', error);
                showNotification('Failed to save changes', 'error');
                
                // Restore original content on error
                const postElement = document.querySelector(`[data-post-id="${postId}"]`);
                const contentDiv = postElement.querySelector('.post-content');
                const originalContent = contentDiv.getAttribute('data-original-content');
                if (originalContent) {
                    contentDiv.innerHTML = originalContent;
                }
                
            } finally {
                // Reset button state
                if (saveBtn) {
                    saveBtn.textContent = originalText;
                    saveBtn.disabled = false;
                }
            }
        }

        function cancelInlineEdit(postId) {
            const postElement = document.querySelector(`[data-post-id="${postId}"]`);
            const contentDiv = postElement.querySelector('.post-content');
            const editBtn = postElement.querySelector('button[onclick*="toggleInlineEdit"]');
            
            // Restore original content
            const originalContent = contentDiv.getAttribute('data-original-content');
            contentDiv.innerHTML = originalContent;
            
            // Reset edit button
            editBtn.innerHTML = '✏️ Edit';
            editBtn.style.color = '#007bff';
        }

        // For backward compatibility with old edit button
        function editPost(postId) {
            toggleInlineEdit(postId);
        }
        
        // Close inline edit on escape key
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                // Find any active inline edit
                const editingTextarea = document.querySelector('[id^="edit-textarea-"]');
                if (editingTextarea) {
                    const postId = editingTextarea.id.replace('edit-textarea-', '');
                    cancelInlineEdit(postId);
                }
            }
        });

        // COMMENTS FUNCTIONALITY
        const postCommentStates = {};

        // Submit comment to a post
        async function submitPostComment(postId) {
            const textarea = document.getElementById('commentText-' + postId);
            if (!textarea) {
                console.error('Comment textarea not found for post:', postId);
                return;
            }
            
            const content = textarea.value.trim();
            if (!content) {
                showNotification('Please enter a comment', 'warning');
                return;
            }
            
            if (content.length > 2000) {
                showNotification('Comment is too long. Maximum 2000 characters allowed.', 'warning');
                return;
            }
            
            const currentUser = getCurrentUser();
            if (!currentUser) {
                showNotification('Please log in to post comments', 'warning');
                return;
            }
            
            try {
                const { data, error } = await window.dcfSupabase
                    .from('comments')
                    .insert({
                        content_type: 'post',
                        content_id: postId,
                        author_id: currentUser.id,
                        author_email: currentUser.email,
                        author_name: '@' + currentUser.username,
                        comment_text: content,
                        parent_comment_id: null,
                        like_count: 0,
                        is_deleted: false,
                        created_at: new Date().toISOString(),
                        updated_at: new Date().toISOString()
                    })
                    .select()
                    .single();
                    
                if (error) throw error;
                
                textarea.value = '';
                await loadPostComments(postId);
                showNotification('Comment posted successfully', 'success');
                
            } catch (error) {
                console.error('Error posting comment:', error);
                showNotification('Failed to post comment', 'error');
            }
        }

        // Load comments for a post
        async function loadPostComments(postId, sortType = null) {
            // Use stored preference or default to 'newest'
            const actualSortType = sortType || postSortPreferences[postId] || 'newest';
            console.log('📖 Loading comments for post:', postId, 'Sort:', actualSortType);
            
            try {
                // Build the simple query that works
                let query = window.dcfSupabase
                    .from('comments')
                    .select('*')
                    .eq('content_type', 'post')
                    .eq('content_id', postId);
                
                // Apply sorting based on type
                switch(actualSortType) {
                    case 'newest':
                        query = query.order('created_at', { ascending: false });
                        break;
                    case 'oldest':
                        query = query.order('created_at', { ascending: true });
                        break;
                    case 'liked':
                        // Sort by like_count (or use created_at as fallback if like_count doesn't exist)
                        query = query.order('like_count', { ascending: false, nullsFirst: false })
                                    .order('created_at', { ascending: false });
                        break;
                    case 'replies':
                        // This will need special handling after fetching
                        query = query.order('created_at', { ascending: false });
                        break;
                    default:
                        query = query.order('created_at', { ascending: false });
                }
                
                const { data: comments, error } = await query;
                    
                if (error) throw error;
                
                // If sorting by replies, we need to count replies for each comment
                let sortedComments = comments || [];
                if (actualSortType === 'replies') {
                    // Count replies for each main comment
                    const mainComments = sortedComments.filter(c => !c.parent_comment_id);
                    const commentReplyCounts = {};
                    
                    mainComments.forEach(comment => {
                        const replyCount = sortedComments.filter(c => c.parent_comment_id === comment.id).length;
                        commentReplyCounts[comment.id] = replyCount;
                    });
                    
                    // Sort main comments by reply count
                    mainComments.sort((a, b) => {
                        return (commentReplyCounts[b.id] || 0) - (commentReplyCounts[a.id] || 0);
                    });
                    
                    // Rebuild the array with sorted main comments first, then their replies
                    const finalSorted = [];
                    mainComments.forEach(comment => {
                        finalSorted.push(comment);
                        const replies = sortedComments.filter(c => c.parent_comment_id === comment.id);
                        finalSorted.push(...replies);
                    });
                    
                    sortedComments = finalSorted;
                }
                
                console.log(`✅ Loaded ${sortedComments.length} comments for post:`, postId);
                await displayPostComments(postId, sortedComments, actualSortType);
                
            } catch (error) {
                console.error('❌ Error loading comments:', error);
                const container = document.getElementById('commentsList-' + postId);
                if (container) {
                    container.innerHTML = '<div class="comments-empty">Error loading comments. Please refresh.</div>';
                }
            }
        }

        // Display comments for a post
        async function displayPostComments(postId, comments, sortType = 'newest') {
            const container = document.getElementById('commentsList-' + postId);
            if (!container) return;
            
            if (comments.length === 0) {
                container.innerHTML = '<div class="comments-empty">No comments yet</div>';
                return;
            }
            
            // Fetch avatars for all comments
            const uniqueAuthorIds = [...new Set(comments.map(c => c.author_id).filter(id => id))];
            await Promise.all(uniqueAuthorIds.map(id => fetchUserAvatar(id)));
            
            // Separate main comments and replies
            let mainComments = comments.filter(c => !c.parent_comment_id);
            const replies = comments.filter(c => c.parent_comment_id);
            const currentUser = getCurrentUser();
            
            // Apply sorting to main comments based on sortType
            if (sortType === 'newest') {
                mainComments.sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
            } else if (sortType === 'oldest') {
                mainComments.sort((a, b) => new Date(a.created_at) - new Date(b.created_at));
            } else if (sortType === 'liked') {
                mainComments.sort((a, b) => (b.like_count || 0) - (a.like_count || 0));
            } else if (sortType === 'replies') {
                // Sort by number of replies (already handled in loadPostComments)
                // Keep the order as received
            }
            
            // Initialize comment state for this post
            if (!(postId in postCommentStates)) {
                postCommentStates[postId] = {
                    showingAll: mainComments.length <= 2,
                    allComments: comments
                };
            }
            
            if (postCommentStates[postId].showingAll) {
                // Show all comments
                const commentsHtml = mainComments.map(comment => {
                    return createFullCommentHtml(comment, replies, currentUser, postId);
                }).join('');
                
                container.innerHTML = commentsHtml;
                
                // Add collapse link if there are 3+ comments
                if (mainComments.length > 2) {
                    const collapseLink = `
                        <div style="margin-left: 2rem; padding: 0.75rem 0; color: #666; font-style: italic; font-size: 0.9rem;">
                            <span onclick="togglePostComments('${postId}')" style="color: #007bff; cursor: pointer; text-decoration: underline;">Show popular comment only</span>
                        </div>
                    `;
                    container.innerHTML += collapseLink;
                }
            } else {
                // Show only most popular comment
                const sortedByPopularity = [...mainComments].sort((a, b) => {
                    const likesA = a.like_count || 0;
                    const likesB = b.like_count || 0;
                    
                    if (likesB !== likesA) {
                        return likesB - likesA;
                    }
                    
                    return new Date(b.created_at) - new Date(a.created_at);
                });
                
                const popularComment = sortedByPopularity[0];
                const commentReplies = replies.filter(r => r.parent_comment_id === popularComment.id);
                const replyCount = commentReplies.length;
                
                const popularCommentHtml = createPopularCommentHtml(popularComment, replyCount, currentUser, postId);
                
                const totalComments = mainComments.length;
                const totalReplies = replies.length;
                const summaryLine = `
                    <div style="margin-top: 1rem; padding: 0.75rem; background: #f8f9fa; border-radius: 6px; color: #666; font-size: 0.9rem;">
                        ${totalComments} comments, ${totalReplies} replies - <span onclick="togglePostComments('${postId}')" style="color: #007bff; cursor: pointer; text-decoration: underline;">Click to see all comments</span>
                    </div>
                `;
                
                container.innerHTML = popularCommentHtml + summaryLine;
            }
            
            // Update comment count
            const mainCommentsCount = mainComments.length;
            const countElement = document.getElementById('totalComments-' + postId);
            const commentCountElement = document.getElementById('commentCount-' + postId);
            if (countElement) countElement.textContent = mainCommentsCount;
            if (commentCountElement) commentCountElement.textContent = mainCommentsCount;
        }

        // Create HTML for a full comment with replies
        function createFullCommentHtml(comment, replies, currentUser, postId) {
            // Generate avatar HTML for main comment - check if it's current user first
            let commentAvatarHTML = '';
            
            // Check if comment is from current user (same logic as post creation box)
            const isCurrentUserComment = currentUser && comment.author_email === currentUser.email;
            
            if (isCurrentUserComment && currentUser.avatar_url) {
                // Current user with avatar - use exact same logic as post creation box
                commentAvatarHTML = `<div class="comment-avatar" style="background: url(${currentUser.avatar_url}) center/cover;"></div>`;
            } else if (isCurrentUserComment) {
                // Current user without avatar - generate initials same as post creation box
                let initials = '';
                if (currentUser.first_name && currentUser.last_name) {
                    initials = currentUser.first_name[0] + currentUser.last_name[0];
                } else if (currentUser.username) {
                    initials = currentUser.username.substring(0, 2);
                } else if (currentUser.email) {
                    initials = currentUser.email.substring(0, 2);
                } else {
                    initials = 'U';
                }
                commentAvatarHTML = `<div class="comment-avatar" style="background: linear-gradient(135deg, #667eea, #764ba2); color: white; display: flex; align-items: center; justify-content: center; font-weight: 600;">${initials.toUpperCase()}</div>`;
            } else {
                // Other users - check cache or use fallback
                const avatarUrl = userAvatarCache[comment.author_id];
                if (avatarUrl) {
                    commentAvatarHTML = `<div class="comment-avatar" style="background: url(${avatarUrl}) center/cover;"></div>`;
                } else {
                    const initials = comment.author_name ? generateInitials(comment.author_name.replace('@', '')) : 'UN';
                    commentAvatarHTML = `<div class="comment-avatar">${initials}</div>`;
                }
            }
            
            const timeAgo = formatTimeAgo(comment.created_at);
            const isOwnComment = currentUser && comment.author_email === currentUser.email;
            
            // Get replies for this comment
            const commentReplies = replies.filter(r => r.parent_comment_id === comment.id);
            const repliesHtml = commentReplies.map(reply => {
                // Generate avatar HTML for reply - check if it's current user first (same as post creation box)
                let replyAvatarHTML = '';
                const isCurrentUserReply = currentUser && reply.author_email === currentUser.email;
                
                if (isCurrentUserReply && currentUser.avatar_url) {
                    // Current user with avatar - use exact same logic as post creation box
                    replyAvatarHTML = `<div class="comment-avatar" style="width: 24px; height: 24px; font-size: 0.7rem; background: url(${currentUser.avatar_url}) center/cover;"></div>`;
                } else if (isCurrentUserReply) {
                    // Current user without avatar - generate initials same as post creation box
                    let initials = '';
                    if (currentUser.first_name && currentUser.last_name) {
                        initials = currentUser.first_name[0] + currentUser.last_name[0];
                    } else if (currentUser.username) {
                        initials = currentUser.username.substring(0, 2);
                    } else if (currentUser.email) {
                        initials = currentUser.email.substring(0, 2);
                    } else {
                        initials = 'U';
                    }
                    replyAvatarHTML = `<div class="comment-avatar" style="width: 24px; height: 24px; font-size: 0.7rem; background: linear-gradient(135deg, #667eea, #764ba2); color: white; display: flex; align-items: center; justify-content: center; font-weight: 600;">${initials.toUpperCase()}</div>`;
                } else {
                    // Other users - check cache or use fallback
                    const replyAvatarUrl = userAvatarCache[reply.author_id];
                    if (replyAvatarUrl) {
                        replyAvatarHTML = `<div class="comment-avatar" style="width: 24px; height: 24px; font-size: 0.7rem; background: url(${replyAvatarUrl}) center/cover;"></div>`;
                    } else {
                        const replyInitials = reply.author_name ? generateInitials(reply.author_name.replace('@', '')) : 'UN';
                        replyAvatarHTML = `<div class="comment-avatar" style="width: 24px; height: 24px; font-size: 0.7rem;">${replyInitials}</div>`;
                    }
                }
                
                const replyTimeAgo = formatTimeAgo(reply.created_at);
                const isOwnReply = currentUser && reply.author_email === currentUser.email;
                
                return `
                    <div class="reply-container" data-comment-id="${reply.id}" style="margin-left: 2rem; margin-top: 0.75rem;">
                        <div style="display: flex; gap: 0.5rem;">
                            ${replyAvatarHTML}
                            <div style="flex: 1;">
                                <div style="display: flex; align-items: center; justify-content: space-between;">
                                    <div>
                                        <span class="comment-author">${reply.author_name && !reply.author_name.startsWith('@') ? '@' + reply.author_name : reply.author_name}</span>
                                        <span class="comment-date">${replyTimeAgo}</span>
                                    </div>
                                    ${isOwnReply ? `
                                        <div class="comment-actions" style="display: flex; gap: 0.5rem;">
                                            <button onclick="editComment('${reply.id}')" style="background: none; border: none; color: #666; cursor: pointer; padding: 2px 6px; font-size: 0.85rem;">
                                                <svg width="14" height="14" fill="currentColor" viewBox="0 0 16 16">
                                                    <path d="M12.146.146a.5.5 0 0 1 .708 0l3 3a.5.5 0 0 1 0 .708l-10 10a.5.5 0 0 1-.168.11l-5 2a.5.5 0 0 1-.65-.65l2-5a.5.5 0 0 1 .11-.168l10-10zM11.207 2.5L13.5 4.793 14.793 3.5 12.5 1.207 11.207 2.5zm1.586 3L10.5 3.207 4 9.707V10h.5a.5.5 0 0 1 .5.5v.5h.5a.5.5 0 0 1 .5.5v.5h.293l6.5-6.5zm-9.761 5.175l-.106.106-1.528 3.821 3.821-1.528.106-.106A.5.5 0 0 1 5 12.5V12h-.5a.5.5 0 0 1-.5-.5V11h-.5a.5.5 0 0 1-.468-.325z"/>
                                                </svg>
                                            </button>
                                            <button onclick="deleteComment('${reply.id}')" style="background: none; border: none; color: #666; cursor: pointer; padding: 2px 6px; font-size: 0.85rem;">
                                                <svg width="14" height="14" fill="currentColor" viewBox="0 0 16 16">
                                                    <path d="M5.5 5.5A.5.5 0 0 1 6 6v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm2.5 0a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm3 .5a.5.5 0 0 0-1 0v6a.5.5 0 0 0 1 0V6z"/>
                                                    <path fill-rule="evenodd" d="M14.5 3a1 1 0 0 1-1 1H13v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V4h-.5a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1H6a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1h3.5a1 1 0 0 1 1 1v1zM4.118 4L4 4.059V13a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V4.059L11.882 4H4.118zM2.5 3V2h11v1h-11z"/>
                                                </svg>
                                            </button>
                                        </div>
                                    ` : ''}
                                </div>
                                <div class="comment-content">${reply.comment_text}</div>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
            
            return `
                <div class="comment-container" data-comment-id="${comment.id}">
                    <div style="display: flex; gap: 0.75rem;">
                        ${commentAvatarHTML}
                        <div style="flex: 1;">
                            <div style="display: flex; align-items: center; justify-content: space-between;">
                                <div>
                                    <span class="comment-author">${comment.author_name && !comment.author_name.startsWith('@') ? '@' + comment.author_name : comment.author_name}</span>
                                    <span class="comment-date">${timeAgo}</span>
                                </div>
                                <div class="comment-actions" style="display: flex; gap: 0.5rem;">
                                    <button onclick="replyToComment('${comment.id}', '${postId}')" style="background: none; border: none; color: #007bff; cursor: pointer; padding: 2px 8px; font-size: 0.85rem;">
                                        Reply
                                    </button>
                                    ${isOwnComment ? `
                                        <button onclick="editComment('${comment.id}')" style="background: none; border: none; color: #666; cursor: pointer; padding: 2px 6px; font-size: 0.85rem;">
                                            <svg width="14" height="14" fill="currentColor" viewBox="0 0 16 16">
                                                <path d="M12.146.146a.5.5 0 0 1 .708 0l3 3a.5.5 0 0 1 0 .708l-10 10a.5.5 0 0 1-.168.11l-5 2a.5.5 0 0 1-.65-.65l2-5a.5.5 0 0 1 .11-.168l10-10zM11.207 2.5L13.5 4.793 14.793 3.5 12.5 1.207 11.207 2.5zm1.586 3L10.5 3.207 4 9.707V10h.5a.5.5 0 0 1 .5.5v.5h.5a.5.5 0 0 1 .5.5v.5h.293l6.5-6.5zm-9.761 5.175l-.106.106-1.528 3.821 3.821-1.528.106-.106A.5.5 0 0 1 5 12.5V12h-.5a.5.5 0 0 1-.5-.5V11h-.5a.5.5 0 0 1-.468-.325z"/>
                                            </svg>
                                        </button>
                                        <button onclick="deleteComment('${comment.id}')" style="background: none; border: none; color: #666; cursor: pointer; padding: 2px 6px; font-size: 0.85rem;">
                                            <svg width="14" height="14" fill="currentColor" viewBox="0 0 16 16">
                                                <path d="M5.5 5.5A.5.5 0 0 1 6 6v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm2.5 0a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm3 .5a.5.5 0 0 0-1 0v6a.5.5 0 0 0 1 0V6z"/>
                                                <path fill-rule="evenodd" d="M14.5 3a1 1 0 0 1-1 1H13v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V4h-.5a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1H6a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1h3.5a1 1 0 0 1 1 1v1zM4.118 4L4 4.059V13a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V4.059L11.882 4H4.118zM2.5 3V2h11v1h-11z"/>
                                            </svg>
                                        </button>
                                    ` : ''}
                                </div>
                            </div>
                            <div class="comment-content">${comment.comment_text}</div>
                            
                            <!-- Reply Form -->
                            <div id="replyForm-${comment.id}" style="display: none; margin-top: 0.75rem; padding: 0.75rem; background: #f8f9fa; border-radius: 6px; border: 1px solid #e9ecef;">
                                <div style="display: flex; gap: 0.5rem;">
                                    <div class="comment-avatar" id="replyAvatar-${comment.id}" style="width: 32px; height: 32px; font-size: 0.75rem; ${currentUser && currentUser.avatar_url ? `background: url(${currentUser.avatar_url}) center/cover;` : ''}">
                                        ${currentUser && currentUser.avatar_url ? '' : (currentUser && currentUser.first_name && currentUser.last_name ? (currentUser.first_name[0] + currentUser.last_name[0]).toUpperCase() : (currentUser && currentUser.username ? generateInitials(currentUser.username) : 'U'))}
                                    </div>
                                    <div style="flex: 1;">
                                        <textarea id="replyText-${comment.id}" placeholder="Write a reply..." style="width: 100%; min-height: 60px; padding: 0.5rem; border: 1px solid #dee2e6; border-radius: 4px; font-size: 0.85rem; resize: vertical; font-family: inherit;"></textarea>
                                        <div style="display: flex; gap: 0.5rem; margin-top: 0.5rem; justify-content: flex-end;">
                                            <button onclick="toggleReplyForm('${comment.id}')" style="background: #6c757d; color: white; border: none; padding: 0.25rem 0.75rem; border-radius: 4px; font-size: 0.75rem; cursor: pointer;">Cancel</button>
                                            <button onclick="submitReply('${comment.id}', '${postId}')" style="background: #007bff; color: white; border: none; padding: 0.25rem 0.75rem; border-radius: 4px; font-size: 0.75rem; cursor: pointer;">Submit Reply</button>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    ${repliesHtml}
                </div>
            `;
        }

        // Create HTML for popular comment display
        function createPopularCommentHtml(comment, replyCount, currentUser, postId) {
            // Generate avatar HTML - check if it's current user first (same as post creation box)
            let avatarHTML = '';
            const isCurrentUserComment = currentUser && comment.author_email === currentUser.email;
            
            if (isCurrentUserComment && currentUser.avatar_url) {
                // Current user with avatar - use exact same logic as post creation box
                avatarHTML = `<div class="comment-avatar" style="background: url(${currentUser.avatar_url}) center/cover;"></div>`;
            } else if (isCurrentUserComment) {
                // Current user without avatar - generate initials same as post creation box
                let initials = '';
                if (currentUser.first_name && currentUser.last_name) {
                    initials = currentUser.first_name[0] + currentUser.last_name[0];
                } else if (currentUser.username) {
                    initials = currentUser.username.substring(0, 2);
                } else if (currentUser.email) {
                    initials = currentUser.email.substring(0, 2);
                } else {
                    initials = 'U';
                }
                avatarHTML = `<div class="comment-avatar" style="background: linear-gradient(135deg, #667eea, #764ba2); color: white; display: flex; align-items: center; justify-content: center; font-weight: 600;">${initials.toUpperCase()}</div>`;
            } else {
                // Other users - check cache or use fallback
                const avatarUrl = userAvatarCache[comment.author_id];
                if (avatarUrl) {
                    avatarHTML = `<div class="comment-avatar" style="background: url(${avatarUrl}) center/cover;"></div>`;
                } else {
                    const initials = comment.author_name ? generateInitials(comment.author_name.replace('@', '')) : 'UN';
                    avatarHTML = `<div class="comment-avatar">${initials}</div>`;
                }
            }
            
            const timeAgo = formatTimeAgo(comment.created_at);
            const isOwnComment = currentUser && comment.author_email === currentUser.email;
            
            return `
                <div class="comment-container" data-comment-id="${comment.id}">
                    <div style="display: flex; gap: 0.75rem;">
                        ${avatarHTML}
                        <div style="flex: 1;">
                            <div style="display: flex; align-items: center; justify-content: space-between;">
                                <div>
                                    <span class="comment-author">${comment.author_name && !comment.author_name.startsWith('@') ? '@' + comment.author_name : comment.author_name}</span>
                                    <span class="comment-date">${timeAgo}</span>
                                    ${replyCount > 0 ? `<span style="color: #007bff; font-size: 0.75rem; background: #f8f9fa; padding: 0.125rem 0.25rem; border-radius: 3px;">${replyCount} replies</span>` : ''}
                                </div>
                                <div class="comment-actions" style="display: flex; gap: 0.5rem;">
                                    <button onclick="replyToComment('${comment.id}', '${postId}')" style="background: none; border: none; color: #007bff; cursor: pointer; padding: 2px 8px; font-size: 0.85rem;">
                                        Reply
                                    </button>
                                    ${isOwnComment ? `
                                        <button onclick="editComment('${comment.id}')" style="background: none; border: none; color: #666; cursor: pointer; padding: 2px 6px; font-size: 0.85rem;">
                                            <svg width="14" height="14" fill="currentColor" viewBox="0 0 16 16">
                                                <path d="M12.146.146a.5.5 0 0 1 .708 0l3 3a.5.5 0 0 1 0 .708l-10 10a.5.5 0 0 1-.168.11l-5 2a.5.5 0 0 1-.65-.65l2-5a.5.5 0 0 1 .11-.168l10-10zM11.207 2.5L13.5 4.793 14.793 3.5 12.5 1.207 11.207 2.5zm1.586 3L10.5 3.207 4 9.707V10h.5a.5.5 0 0 1 .5.5v.5h.5a.5.5 0 0 1 .5.5v.5h.293l6.5-6.5zm-9.761 5.175l-.106.106-1.528 3.821 3.821-1.528.106-.106A.5.5 0 0 1 5 12.5V12h-.5a.5.5 0 0 1-.5-.5V11h-.5a.5.5 0 0 1-.468-.325z"/>
                                            </svg>
                                        </button>
                                        <button onclick="deleteComment('${comment.id}')" style="background: none; border: none; color: #666; cursor: pointer; padding: 2px 6px; font-size: 0.85rem;">
                                            <svg width="14" height="14" fill="currentColor" viewBox="0 0 16 16">
                                                <path d="M5.5 5.5A.5.5 0 0 1 6 6v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm2.5 0a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm3 .5a.5.5 0 0 0-1 0v6a.5.5 0 0 0 1 0V6z"/>
                                                <path fill-rule="evenodd" d="M14.5 3a1 1 0 0 1-1 1H13v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V4h-.5a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1H6a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1h3.5a1 1 0 0 1 1 1v1zM4.118 4L4 4.059V13a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V4.059L11.882 4H4.118zM2.5 3V2h11v1h-11z"/>
                                            </svg>
                                        </button>
                                    ` : ''}
                                </div>
                            </div>
                            <div class="comment-content">${comment.comment_text}</div>
                            
                            <!-- Reply Form -->
                            <div id="replyForm-${comment.id}" style="display: none; margin-top: 0.75rem; padding: 0.75rem; background: #f8f9fa; border-radius: 6px; border: 1px solid #e9ecef;">
                                <div style="display: flex; gap: 0.5rem;">
                                    <div class="comment-avatar" id="replyAvatar-${comment.id}" style="width: 32px; height: 32px; font-size: 0.75rem; ${currentUser && currentUser.avatar_url ? `background: url(${currentUser.avatar_url}) center/cover;` : ''}">
                                        ${currentUser && currentUser.avatar_url ? '' : (currentUser && currentUser.first_name && currentUser.last_name ? (currentUser.first_name[0] + currentUser.last_name[0]).toUpperCase() : (currentUser && currentUser.username ? generateInitials(currentUser.username) : 'U'))}
                                    </div>
                                    <div style="flex: 1;">
                                        <textarea id="replyText-${comment.id}" placeholder="Write a reply..." style="width: 100%; min-height: 60px; padding: 0.5rem; border: 1px solid #dee2e6; border-radius: 4px; font-size: 0.85rem; resize: vertical; font-family: inherit;"></textarea>
                                        <div style="display: flex; gap: 0.5rem; margin-top: 0.5rem; justify-content: flex-end;">
                                            <button onclick="toggleReplyForm('${comment.id}')" style="background: #6c757d; color: white; border: none; padding: 0.25rem 0.75rem; border-radius: 4px; font-size: 0.75rem; cursor: pointer;">Cancel</button>
                                            <button onclick="submitReply('${comment.id}', '${postId}')" style="background: #007bff; color: white; border: none; padding: 0.25rem 0.75rem; border-radius: 4px; font-size: 0.75rem; cursor: pointer;">Submit Reply</button>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        // Toggle between showing all comments and popular comment
        function togglePostComments(postId) {
            console.log('🔄 Toggling comments for post:', postId);
            
            if (!postCommentStates[postId]) {
                postCommentStates[postId] = {
                    showingAll: false,
                    allComments: []
                };
            }
            
            postCommentStates[postId].showingAll = !postCommentStates[postId].showingAll;
            loadPostComments(postId);
        }

        // Delete a comment
        async function deleteComment(commentId) {
            if (!await showConfirm('Are you sure you want to delete this comment?')) return;
            
            try {
                const { error } = await window.dcfSupabase
                    .from('comments')
                    .delete()
                    .eq('id', commentId);
                    
                if (error) throw error;
                
                showNotification('Comment deleted successfully', 'success');
                
                // Find the post ID and reload comments
                const commentElement = document.querySelector(`[data-comment-id="${commentId}"]`);
                if (commentElement) {
                    const postElement = commentElement.closest('.post-card');
                    if (postElement) {
                        const postId = postElement.getAttribute('data-post-id');
                        await loadPostComments(postId);
                    }
                }
                
            } catch (error) {
                console.error('Error deleting comment:', error);
                showNotification('Failed to delete comment', 'error');
            }
        }

        // Sort comments
        // Store sort preferences for each post
        const postSortPreferences = {};
        
        function sortComments(sortType, postId) {
            console.log('🔄 Sorting comments by:', sortType, 'for post:', postId);
            
            // Store the sort preference for this post
            postSortPreferences[postId] = sortType;
            
            // Update button states
            const container = document.querySelector(`[data-post-id="${postId}"]`);
            if (container) {
                const buttons = container.querySelectorAll('.sort-btn');
                buttons.forEach(btn => {
                    btn.classList.remove('active');
                    btn.style.background = '#f8f9fa';
                    btn.style.color = '#666';
                    btn.style.border = '1px solid #e5e5e5';
                });
                
                const activeBtn = container.querySelector(`[data-sort="${sortType}"]`);
                if (activeBtn) {
                    activeBtn.classList.add('active');
                    activeBtn.style.background = 'linear-gradient(135deg, #000, #333)';
                    activeBtn.style.color = 'white';
                    activeBtn.style.border = 'none';
                }
            }
            
            // Reload comments with the new sort order
            loadPostComments(postId, sortType);
        }

        // Edit comment function - convert to inline editing
        function editComment(commentId) {
            const currentUser = window.getCurrentUser();
            if (!currentUser) {
                showNotification('Please log in to edit comments', 'error');
                return;
            }
            
            const commentElement = document.querySelector(`[data-comment-id="${commentId}"] .comment-content`);
            if (!commentElement) return;
            
            // Check if already editing
            if (commentElement.querySelector('textarea')) return;
            
            const currentText = commentElement.textContent;
            
            // Replace content with edit form
            commentElement.innerHTML = `
                <textarea id="editText-${commentId}" style="width: 100%; min-height: 60px; padding: 0.5rem; border: 1px solid #dee2e6; border-radius: 4px; font-size: 0.85rem; resize: vertical; font-family: inherit;">${currentText}</textarea>
                <div style="display: flex; gap: 0.5rem; margin-top: 0.5rem; justify-content: flex-end;">
                    <button onclick="cancelEditComment('${commentId}')" style="background: #6c757d; color: white; border: none; padding: 0.25rem 0.75rem; border-radius: 4px; font-size: 0.75rem; cursor: pointer;">Cancel</button>
                    <button onclick="saveEditComment('${commentId}')" style="background: #007bff; color: white; border: none; padding: 0.25rem 0.75rem; border-radius: 4px; font-size: 0.75rem; cursor: pointer;">Save</button>
                </div>
            `;
            
            // Focus the textarea
            const textarea = document.getElementById(`editText-${commentId}`);
            if (textarea) {
                textarea.focus();
                textarea.setSelectionRange(textarea.value.length, textarea.value.length);
            }
        }
        
        // Save edited comment
        async function saveEditComment(commentId) {
            const textarea = document.getElementById(`editText-${commentId}`);
            if (!textarea) return;
            
            const newText = textarea.value.trim();
            if (!newText) {
                showNotification('Comment cannot be empty', 'error');
                return;
            }
            
            const currentUser = window.getCurrentUser();
            if (!currentUser) return;
            
            try {
                const { error } = await window.dcfSupabase
                    .from('comments')
                    .update({ 
                        comment_text: newText,
                        updated_at: new Date().toISOString()
                    })
                    .eq('id', commentId)
                    .eq('author_email', currentUser.email);
                
                if (error) throw error;
                
                // Update UI
                const commentElement = document.querySelector(`[data-comment-id="${commentId}"] .comment-content`);
                commentElement.innerHTML = newText + ' <span style="color: #999; font-size: 0.8em;">(edited)</span>';
                showNotification('Comment updated', 'success');
            } catch (error) {
                console.error('Error editing comment:', error);
                showNotification('Failed to update comment', 'error');
            }
        }
        
        // Cancel comment editing
        function cancelEditComment(commentId) {
            const commentElement = document.querySelector(`[data-comment-id="${commentId}"] .comment-content`);
            const textarea = document.getElementById(`editText-${commentId}`);
            
            if (commentElement && textarea) {
                // Get the original text from the textarea (before any edits)
                const originalText = textarea.defaultValue;
                commentElement.textContent = originalText;
            }
        }
        
        // Toggle reply form visibility
        function toggleReplyForm(commentId) {
            const form = document.getElementById('replyForm-' + commentId);
            if (form) {
                const isVisible = form.style.display !== 'none';
                form.style.display = isVisible ? 'none' : 'block';
                if (!isVisible) {
                    // Update the avatar with current user data when showing the form
                    let currentUser = window.getCurrentUser();
                    
                    // Fallback to dcfUser if getCurrentUser returns null
                    if (!currentUser && window.dcfUser && window.dcfUser.isLoggedIn) {
                        currentUser = window.dcfUser.profile;
                    }
                    
                    const avatarElement = document.getElementById('replyAvatar-' + commentId);
                    if (avatarElement && currentUser) {
                        // Use EXACT same logic as updatePostCreationUserDisplay
                        if (currentUser.avatar_url) {
                            // User has profile image
                            avatarElement.style.background = `url(${currentUser.avatar_url}) center/cover`;
                            avatarElement.textContent = '';
                        } else {
                            // Generate initials using same logic as main post box
                            avatarElement.style.background = 'linear-gradient(135deg, #667eea, #764ba2)';
                            let initials = '';
                            if (currentUser.first_name && currentUser.last_name) {
                                initials = currentUser.first_name[0] + currentUser.last_name[0];
                            } else if (currentUser.username) {
                                initials = generateInitials(currentUser.username);
                            } else if (currentUser.email) {
                                initials = currentUser.email.substring(0, 2);
                            } else {
                                initials = 'U';
                            }
                            avatarElement.textContent = initials.toUpperCase();
                        }
                    }
                    
                    const textarea = document.getElementById('replyText-' + commentId);
                    if (textarea) {
                        textarea.focus();
                        textarea.value = '';
                    }
                }
            }
        }
        
        // Show reply form when Reply button is clicked
        function replyToComment(commentId, postId) {
            toggleReplyForm(commentId);
        }
        
        // Submit reply to a comment
        async function submitReply(commentId, postId) {
            console.log('🔵 submitReply called with:', { commentId, postId });
            
            const textarea = document.getElementById('replyText-' + commentId);
            console.log('🔵 Textarea element:', textarea);
            if (!textarea) {
                console.error('❌ Textarea not found for commentId:', commentId);
                return;
            }
            
            const content = textarea.value.trim();
            console.log('🔵 Reply text content:', content);
            console.log('🔵 Reply text length:', content.length);
            
            if (!content) {
                console.warn('⚠️ Empty reply text');
                showNotification('Please enter a reply', 'warning');
                return;
            }
            
            const currentUser = window.getCurrentUser();
            console.log('🔵 Current user:', currentUser);
            
            if (!currentUser) {
                console.error('❌ No current user found');
                showNotification('Please log in to reply', 'error');
                return;
            }
            
            // Prepare insert data
            const insertData = {
                content_type: 'post',
                content_id: postId,
                parent_comment_id: commentId,
                author_name: '@' + (currentUser.username || currentUser.email.split('@')[0]),
                author_email: currentUser.email,
                author_id: currentUser.id,
                comment_text: content,
                created_at: new Date().toISOString()
            };
            
            console.log('🔵 Insert data prepared:', insertData);
            console.log('🔵 Using comments table with content_type="post"');
            
            try {
                console.log('🔵 Attempting database insert...');
                
                const { data, error } = await window.dcfSupabase
                    .from('comments')
                    .insert(insertData)
                    .select()
                    .single();
                
                console.log('🔵 Database response:', { data, error });
                
                if (error) {
                    console.error('❌ Database error:', error);
                    console.error('❌ Error details:', {
                        message: error.message,
                        details: error.details,
                        hint: error.hint,
                        code: error.code
                    });
                    throw error;
                }
                
                console.log('✅ Reply inserted successfully:', data);
                
                // Clear and hide the reply form
                textarea.value = '';
                toggleReplyForm(commentId);
                
                // Reload comments to show the new reply
                console.log('🔵 Reloading comments for postId:', postId);
                loadPostComments(postId);
                showNotification('Reply posted', 'success');
            } catch (error) {
                console.error('❌ Error posting reply:', error);
                console.error('❌ Full error object:', error);
                showNotification('Failed to post reply: ' + (error.message || 'Unknown error'), 'error');
            }
        }

        // Add keyboard shortcuts for comments and replies
        document.addEventListener('keydown', function(e) {
            // Handle main comment submission
            if (e.target.id && e.target.id.startsWith('commentText-')) {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    const postId = e.target.id.replace('commentText-', '');
                    submitPostComment(postId);
                }
            }
            
            // Handle reply submission and cancellation
            if (e.target.id && e.target.id.startsWith('replyText-')) {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    const commentId = e.target.id.replace('replyText-', '');
                    console.log('🔷 Enter key pressed on reply textarea for commentId:', commentId);
                    
                    const postElement = e.target.closest('.post-card');
                    console.log('🔷 Found post element:', postElement);
                    
                    if (postElement) {
                        const postId = postElement.getAttribute('data-post-id');
                        console.log('🔷 Extracted postId from data-post-id:', postId);
                        submitReply(commentId, postId);
                    } else {
                        console.error('❌ Could not find parent .post-card element');
                    }
                } else if (e.key === 'Escape') {
                    const commentId = e.target.id.replace('replyText-', '');
                    console.log('🔷 Escape key pressed, closing reply form for commentId:', commentId);
                    toggleReplyForm(commentId);
                }
            }
        });
        
   </script>

   <!-- Image Modal -->
   <div id="imageModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.95); z-index: 10000; align-items: center; justify-content: center;" onclick="closeImageModal()">
       <div style="position: relative; max-width: 90vw; max-height: 90vh;" onclick="event.stopPropagation()">
           <img id="modalImage" style="max-width: 100%; max-height: 100%; object-fit: contain; border-radius: 12px; box-shadow: 0 8px 32px rgba(0,0,0,0.5);">
           <button onclick="closeImageModal(); event.stopPropagation();" style="position: absolute; top: 12px; right: 12px; background: rgba(0,0,0,0.7); color: white; border: none; border-radius: 50%; width: 40px; height: 40px; cursor: pointer; font-size: 1.2rem; font-weight: bold; z-index: 10001; transition: background 0.2s ease;" onmouseover="this.style.background='rgba(0,0,0,0.9)'" onmouseout="this.style.background='rgba(0,0,0,0.7)'">×</button>
       </div>
   </div>

   <!-- Image Gallery Modal with Navigation -->
   <div id="imageGalleryModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.95); z-index: 10001; align-items: center; justify-content: center;" onclick="closeImageGallery()">
       <div style="position: relative; max-width: 90vw; max-height: 90vh; display: flex; align-items: center; justify-content: center;">
           
           <!-- Main Image Container -->
           <div style="position: relative; max-width: 100%; max-height: 100%; display: flex; align-items: center; justify-content: center;" onclick="event.stopPropagation()">
               <img id="galleryImage" style="max-width: 90vw; max-height: 90vh; width: auto; height: auto; object-fit: contain; border-radius: 12px; box-shadow: 0 8px 32px rgba(0,0,0,0.5);">
           </div>
           
           <!-- Left Arrow -->
           <button id="galleryPrevBtn" onclick="previousImage(); event.stopPropagation();" style="position: absolute; left: 20px; top: 50%; transform: translateY(-50%); background: rgba(255,255,255,0.2); color: white; border: none; border-radius: 50%; width: 60px; height: 60px; cursor: pointer; font-size: 24px; font-weight: bold; backdrop-filter: blur(10px); transition: all 0.3s ease; z-index: 10002;" onmouseover="this.style.background='rgba(255,255,255,0.3)'; this.style.transform='translateY(-50%) scale(1.1)'" onmouseout="this.style.background='rgba(255,255,255,0.2)'; this.style.transform='translateY(-50%) scale(1)'">
               ‹
           </button>
           
           <!-- Right Arrow -->
           <button id="galleryNextBtn" onclick="nextImage(); event.stopPropagation();" style="position: absolute; right: 20px; top: 50%; transform: translateY(-50%); background: rgba(255,255,255,0.2); color: white; border: none; border-radius: 50%; width: 60px; height: 60px; cursor: pointer; font-size: 24px; font-weight: bold; backdrop-filter: blur(10px); transition: all 0.3s ease; z-index: 10002;" onmouseover="this.style.background='rgba(255,255,255,0.3)'; this.style.transform='translateY(-50%) scale(1.1)'" onmouseout="this.style.background='rgba(255,255,255,0.2)'; this.style.transform='translateY(-50%) scale(1)'">
               ›
           </button>
           
           <!-- Image Counter -->
           <div id="imageCounter" style="position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.8); color: white; padding: 8px 16px; border-radius: 20px; font-size: 14px; backdrop-filter: blur(10px); z-index: 10002;">
               1 of 1
           </div>
           
           <!-- Close Button -->
           <button onclick="closeImageGallery(); event.stopPropagation();" style="position: absolute; top: 12px; right: 12px; background: rgba(0,0,0,0.7); color: white; border: none; border-radius: 50%; width: 40px; height: 40px; cursor: pointer; font-size: 1.2rem; font-weight: bold; z-index: 10002; transition: background 0.2s ease;" onmouseover="this.style.background='rgba(0,0,0,0.9)'" onmouseout="this.style.background='rgba(0,0,0,0.7)'">
               ×
           </button>
       </div>
   </div>

</body>
</html>